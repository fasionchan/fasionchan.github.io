<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[fasionchan]]></title>
  <link href="http://blog.fasionchan.com/atom.xml" rel="self"/>
  <link href="http://blog.fasionchan.com/"/>
  <updated>2017-07-03T14:46:52+08:00</updated>
  <id>http://blog.fasionchan.com/</id>
  <author>
    <name><![CDATA[陈彦霏]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[译文]跳表：一种平衡树的概率性替代品]]></title>
    <link href="http://blog.fasionchan.com/blog/2017/06/17/yi-wen-tiao-biao-yi-zhong-ping-heng-shu-de-gai-lu-xing-ti-dai-pin/"/>
    <updated>2017-06-17T16:33:32+08:00</updated>
    <id>http://blog.fasionchan.com/blog/2017/06/17/yi-wen-tiao-biao-yi-zhong-ping-heng-shu-de-gai-lu-xing-ti-dai-pin</id>
    <content type="html"><![CDATA[<p> <strong>跳表</strong>是一种可以替代<strong>平衡树</strong>的数据结构。跳表追求的是概率性平衡，而不是严格平衡。因此，跟平衡二叉树相比，跳表的<strong>插入</strong>和<strong>删除</strong>操作要简单得多，执行也更快。</p>

<p>二叉树可以用来实现字典和有序表等抽象数据结构。在元素随机插入的场景，二叉树可以很好应对。然而，在有序插入的情况下，二叉树就退化了(链表)，性能非常差。如果有办法对待插入元素进行随机排列，二叉树大概率可以运行良好。大部分情况下，插入是在线进行的，因此随机排列并不具有可行性。平衡树在操作时对树结构进行调整以满足平衡条件，因此获得理想性能。</p>

<p>跳表是一种概率性可行的平衡二叉树替代数据结构。跳表通过一个<strong>随机数生成器</strong>实现平衡。虽然跳表最坏情况下(<code>worst-case</code>)性能也很差，但是没有任何输入序列必然会导致最坏情况发生(这点类似划分元素(<code>pivot point</code>)随机选定的<strong>快排</strong>)。跳表极度不平衡发生的概率非常低(一个包含<code>250</code>个元素的字典，一次查找需要花<code>3</code>倍期望时间的概率小于百万分之一)。跳表平衡概率跟随机插入的二叉树差不多，好处是插入顺序不要求随机。</p>

<!--more-->


<p>实现概率性平衡比严格控制平衡要简单得多。对很多应用来说，跳表用起来比平衡树更自然，而且算法更简单。跳表算法简单性意味着更容易实现，而且与平衡树和自适应树相比有常数倍数的性能提升。跳表在空间上也比较高效。平均每个元素只需要额外耗费个2指针(甚至可以配置得更低)，并不需要在每个节点上都存与平衡和优先级相关的数据。</p>

<h2>结构</h2>

<p><img src="http://upload-images.jianshu.io/upload_images/2740477-7dc366ea883cf19b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png" /></p>

<p>搜索一个链表时，我们需要遍历每个节点(如图 1a)。如果列表是有序的，偶数节点另存一个指向下一个偶数节点的指针(如图 1b)，我们只需要检查最多<code>(n/2)+1</code>个节点(<code>n</code>是链表规模)。如果序号为<code>4</code>的倍数的节点都有一个往前跳<code>4</code>步的节点，那么最多只需要检查<code>(n/4)+2</code>次。如果，序号为<code>2^i</code>的节点有一个向前跳<code>2^i</code>步的指针，那么则需要检查<code>log2 n</code>次了！这种数据结构可以用来做快速搜索，但是插入和删除并没有可行性。</p>

<p>有<code>k</code>个前进指针的节点成为<code>k</code>层节点。如果第<code>2^i</code>个节点有一个向前跳<code>2^i</code>步的指针，那么每层节点数满足以下关系：第<code>1</code>层有<code>50%</code>的节点；第<code>2</code>层有<code>25%</code>的节点；第<code>3</code>层有<code>12.5%</code>的节点；以此类推。假设每层的比例还是一样，但是节点随机选择，会怎样呢(图 1e)？节点第<code>i</code>个前进指针不严格跳<code>2^i</code>步，而是可以跳任意步。由于不需要维持特殊条件，插入节点层数随机生成，插入和删除只需要做<strong>局部修改</strong>。极端情况下，有些层次分布会导致极差的性能，不过接下来我们会看到这种情况非常罕见。这种数据结构在链表的基础上加上额外指针以跳过一些中间节点，因此命名为<strong>跳表</strong>。</p>

<h2>算法</h2>

<p>这小节介绍用于<strong>搜索</strong>、<strong>插入</strong>、<strong>删除</strong>的算法。<strong>搜索</strong>操作返回与给定键(<code>key</code>)关联的值(<code>value</code>)，键不存在时则失败。<strong>插入</strong>操作将给定键关联到新的值，如果键不存在则插入新的节点。<strong>删除</strong>操作删除给定键。另外，类似<strong>最小键</strong>和<strong>下一键</strong>这类操作实现起来也非常简单。</p>

<p>每个元素由一个节点表示，层次由节点在插入时随机选定，与已有元素无关。层次为<code>i</code>的节点拥有<code>i</code>个前进指针，下标分别是<code>1</code>至<code>i</code>。节点不需要存储层数。选定一个合适的常量<code>MaxLevel</code>，层数在这个范围内。跳表的层数时当前所有节点层数的最大值，或者当跳表为空是，层数为<code>1</code>。用一个头向量存储从层次<code>1</code>到<code>MaxLevel</code>的向前指针。指针高于当前跳表层数的部分直接指向<code>NIL</code>。</p>

<h3>初始化</h3>

<p>约定<code>NIL</code>元素，其键比所有合法建都大(上限)。跳表的任意层都以<code>NIL</code>结尾。新的跳表初始化成层数只有<code>1</code>，并且所有表头所有前进指针都指向<code>NIL</code>。</p>

<h3>查找</h3>

<p>查找某个元素时，需要逐层遍历所有键不超过给定键的节点。如果当前层前进节点已经不符合条件了，往下一层开始遍历。当遍历进行到第<code>1</code>层时，下一个节点就是目标节点(如存在)。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Search(list, searchKey)
</span><span class='line'>    x := list-&gt;header
</span><span class='line'>
</span><span class='line'>    for i := list-&gt;level downto 1 do
</span><span class='line'>        while x-&gt;forward[i]-&gt;key &lt; searchKey do
</span><span class='line'>            x = x-&gt;forward[i]
</span><span class='line'>
</span><span class='line'>    x := x-&gt;forward[1]
</span><span class='line'>
</span><span class='line'>    if x-&gt;key = searchKey
</span><span class='line'>    then
</span><span class='line'>        return x-&gt;value
</span><span class='line'>    else
</span><span class='line'>        return failure</span></code></pre></td></tr></table></div></figure>


<h3>插入/删除</h3>

<p><strong>插入</strong>或者<strong>删除</strong>节点，只需先执行搜索操作(图 3)，然后视情况重新拼接。伪代码如下所示：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Insert(list, searchKey, newValue)
</span><span class='line'>    local update[1..MaxLevel]
</span><span class='line'>    x := list-header
</span><span class='line'>
</span><span class='line'>    for i := list-&gt;level downto 1 do
</span><span class='line'>        while x-&gt;forward[i]-&gt;key &lt; searchKey do
</span><span class='line'>            x := x-&gt;forward[i]
</span><span class='line'>        update[i] := x
</span><span class='line'>
</span><span class='line'>    x := x-&gt;forward[i]
</span><span class='line'>
</span><span class='line'>    if x-&gt;key = searchKey then
</span><span class='line'>        x-&gt;value := newValue
</span><span class='line'>    else
</span><span class='line'>        lvl := randomLevel()
</span><span class='line'>        if lvl &gt; list-&gt;level then
</span><span class='line'>            for i := list-&gt;level+1 to lvl do
</span><span class='line'>                update[i] := list-&gt;header
</span><span class='line'>            list-&gt;level = lvl
</span><span class='line'>        x := makeNode(lvl, searchKey, value)
</span><span class='line'>        for i := 1 to lvl do
</span><span class='line'>            x-&gt;forward[i] = update[i]-&gt;forward[i]
</span><span class='line'>            update[i]-&gt;forward[i] := x</span></code></pre></td></tr></table></div></figure>


<p><img src="http://upload-images.jianshu.io/upload_images/2740477-4c9045f1819efd42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png" /></p>

<p>图3展示了搜索过程。注意到，搜索的过程中维护了一个名为<code>update</code>的向量，在每次降层搜索时更新。搜索完成后，<code>update</code>刚好记录了各层在操作位置(图中环)左边最近的节点：</p>

<table>
<thead>
<tr>
<th style="text-align:left;">元素</th>
<th style="text-align:left;">节点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">update[1]</td>
<td style="text-align:left;">12</td>
</tr>
<tr>
<td style="text-align:left;">update[2]</td>
<td style="text-align:left;">9</td>
</tr>
<tr>
<td style="text-align:left;">update[3]</td>
<td style="text-align:left;">6</td>
</tr>
<tr>
<td style="text-align:left;">update[4]</td>
<td style="text-align:left;">6</td>
</tr>
</tbody>
</table>


<p>如果插入时生成了一个比当前最大层更大的层数，则需要更新跳表层数并且初始化<code>update</code>向量对应部分。</p>

<p>接下来，看看删除操作的伪代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Delete(list, searchKey)
</span><span class='line'>    local update[1..MaxLevel]
</span><span class='line'>    x := list-header
</span><span class='line'>
</span><span class='line'>    for i := list-&gt;level downto 1 do
</span><span class='line'>        while x-&gt;forward[i]-&gt;key &lt; searchKey do
</span><span class='line'>            x := x-&gt;forward[i]
</span><span class='line'>        update[i] := x
</span><span class='line'>
</span><span class='line'>    x := x-&gt;forward[i]
</span><span class='line'>
</span><span class='line'>    if x-&gt;key &lt; searchKey then
</span><span class='line'>        for i := 1 to list-&gt;level do
</span><span class='line'>            if update[i]-&gt;forward[i] != x then break
</span><span class='line'>            update[i]-&gt;forward[i] = x-&gt;forward[i]
</span><span class='line'>
</span><span class='line'>        free(x)
</span><span class='line'>
</span><span class='line'>        while list-&gt;level &gt; 1 and list-&gt;header-&gt;forward[list-&gt;level] = NIL do
</span><span class='line'>            list-&gt;level := list-&gt;level - 1</span></code></pre></td></tr></table></div></figure>


<p>在每次删除时，需要检查被删除节点是否是最大层节点。如果是，需要对跳表层数做对应调整。</p>

<h3>随机函数</h3>

<p>接下来，需啊确定一个随机数生成函数，其概率分布使得第<code>i</code>层中有<code>50%</code>的节点同时数据第<code>i+1</code>层。先抛开具体数值，我们在讨论一个分数<code>p</code>，对于有<code>i</code>层指针的节点中<code>p</code>部分，同时拥有<code>i+1</code>层指针。以下便是一个非常理想的随机数生成函数，随机层数生成与跳表元素及规模无关：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>randomLevel()
</span><span class='line'>    lvl := 1
</span><span class='line'>    while random() &lt; p and lvl &lt; MaxLevel do
</span><span class='line'>        lvl := lvl + 1
</span><span class='line'>    return lvl</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Procfs伪文件系统原理]]></title>
    <link href="http://blog.fasionchan.com/blog/2017/06/16/procfswei-wen-jian-xi-tong-yuan-li/"/>
    <updated>2017-06-16T14:58:23+08:00</updated>
    <id>http://blog.fasionchan.com/blog/2017/06/16/procfswei-wen-jian-xi-tong-yuan-li</id>
    <content type="html"><![CDATA[<p><code>Linux</code>系统<code>/proc</code>目录下，有一些特殊的目录和文件，用来展示或者设置内核数据。例如，<code>/proc/meminfo</code>展示系统内存信息：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cat /proc/meminfo
</span><span class='line'>MemTotal:         506160 kB
</span><span class='line'>MemFree:           73528 kB
</span><span class='line'>MemAvailable:     335160 kB
</span><span class='line'>Buffers:           54756 kB
</span><span class='line'>Cached:           162888 kB
</span><span class='line'>SwapCached:            0 kB
</span><span class='line'>Active:           247648 kB
</span><span class='line'>Inactive:          96840 kB
</span><span class='line'>Active(anon):     127044 kB
</span><span class='line'>Inactive(anon):     4332 kB
</span><span class='line'>Active(file):     120604 kB
</span><span class='line'>Inactive(file):    92508 kB
</span><span class='line'>Unevictable:           0 kB
</span><span class='line'>Mlocked:               0 kB
</span><span class='line'>SwapTotal:             0 kB
</span><span class='line'>SwapFree:              0 kB
</span><span class='line'>Dirty:               104 kB
</span><span class='line'>Writeback:             0 kB
</span><span class='line'>AnonPages:        126824 kB
</span><span class='line'>Mapped:            14412 kB
</span><span class='line'>Shmem:              4532 kB
</span><span class='line'>Slab:              70608 kB
</span><span class='line'>SReclaimable:      59128 kB
</span><span class='line'>SUnreclaim:        11480 kB
</span><span class='line'>KernelStack:        2928 kB
</span><span class='line'>PageTables:         3028 kB
</span><span class='line'>NFS_Unstable:          0 kB
</span><span class='line'>Bounce:                0 kB
</span><span class='line'>WritebackTmp:          0 kB
</span><span class='line'>CommitLimit:      253080 kB
</span><span class='line'>Committed_AS:     530132 kB
</span><span class='line'>VmallocTotal:   34359738367 kB
</span><span class='line'>VmallocUsed:        5536 kB
</span><span class='line'>VmallocChunk:   34359731707 kB
</span><span class='line'>HardwareCorrupted:     0 kB
</span><span class='line'>AnonHugePages:         0 kB
</span><span class='line'>HugePages_Total:       0
</span><span class='line'>HugePages_Free:        0
</span><span class='line'>HugePages_Rsvd:        0
</span><span class='line'>HugePages_Surp:        0
</span><span class='line'>Hugepagesize:       2048 kB
</span><span class='line'>DirectMap4k:       69568 kB
</span><span class='line'>DirectMap2M:      454656 kB</span></code></pre></td></tr></table></div></figure>


<p>这些数据随着系统的变化动态调整，感觉好神奇！</p>

<!--more-->


<p>还有一些文件，直接跟一些内核变量映射。除了可以读出数据，还可以更新数据呢。例如，<code>/proc/sys/net/ipv4/ip_forward</code>用来控制<code>IP</code>包转发，设置为<code>1</code>则是是启用转发：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cat /proc/sys/net/ipv4/ip_forward
</span><span class='line'>0
</span><span class='line'>echo "1" &gt; /proc/sys/net/ipv4/ip_forward
</span><span class='line'>$ cat /proc/sys/net/ipv4/ip_forward
</span><span class='line'>1</span></code></pre></td></tr></table></div></figure>


<p>那么，这些文件本质是什么呢？是真正的文件吗？</p>

<h2>来龙去脉</h2>

<p>系统用户和程序(进程)经常需要某些内核信息，该怎么获得呢？</p>

<p>以<code>/proc/sys/net/ipv4/ip_forward</code>为例，内核里有一个变量用来控制协议栈是否转发<code>IP</code>包。系统用户要控制转发是否开启，就需要去设置这个内核变量。怎么设置呢？要知道用户空间可是没有办法直接访问内核空间的。</p>

<p>可以考虑实现一个新的系统调用——<code>int set_ip_forward(int value)</code>。然而，天呀有好多这样或那样的场景，这样系统调用表是要爆炸的！而且这种方式用起来也麻烦，需要实现一个专用的命令，调用这个系统调用完成设置。</p>

<p>有没有更通用的方式呢？其实，让这个系统调用更加通用化，也是一种思路——<code>int set_kernel_value(char *path, void *value)</code>。这样一个系统调用就搞定了一些列设置要求，但是还是没有解决调用麻烦的问题。</p>

<p>如果，可以将内核数据伪装成一个文件，用<code>read</code>系统调用获取；用<code>write</code>系统调用设置不就完美了吗？这样，有现成的命令可以直接使用，比如用<code>cat</code>来获取，用<code>echo</code>来设置！</p>

<p>那么内核有办法做到吗？</p>

<p>办法肯定是有的。最直观的想法是，在内核处理<code>read</code>的代码进行控制，让<code>read</code>直接从内核数据中拷贝，而不是磁盘。当然了，内核黑客们不会写这么恶心的代码，而是抽象了一层——<code>VFS</code>。</p>

<h2>VFS</h2>

<p><code>Linux</code>支持各种各样的文件系统，光<code>ext</code>系列就有：<code>ext2</code>、<code>ext3</code>、<code>ext4</code>。内核如何实现不同文件系统差异性的呢？</p>

<p>答案是，内核抽象了<code>VFS</code>接口。跟面向对象编程中的接口有点类似，具体的文件系统按照各自的方式分别实现(多态)。</p>

<p><img src="http://upload-images.jianshu.io/upload_images/2740477-e2afa3b8415de815.gif?imageMogr2/auto-orient/strip" alt="archi_VFS-eng.gif" /></p>

<p>如上图所示，不同的文件系统以各自的方式实现处理接口，如<code>read</code>和<code>write</code>等等。这些处理接口被封装成结构一致的结构体注册。这样，同样的系统调用，在不同的文件系统下，由不同的函数处理。</p>

<p>因此，完全有可能实现一个假的文件系统，就叫<code>procfs</code>，读写分别映射为变量的读出和写入。</p>

<h2>流程</h2>

<p>最后，图解说明访问<code>/proc</code>下文件的整个流程：</p>

<p><img src="http://upload-images.jianshu.io/upload_images/2740477-d7d7a62d6c2c427d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="procfs" /></p>

<ol>
<li>用户进程发起一个系统调用<code>read</code>；</li>
<li>内核<code>VFS</code>根据文件描述符找出操作描述体；</li>
<li>内核从描述体取出<code>read</code>处理函数指针；</li>
<li>内核执行该处理函数；</li>
<li>处理函数读出内核变量并拷贝到用户态空间；</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux内核模块]]></title>
    <link href="http://blog.fasionchan.com/blog/2017/06/14/linux-nei-he-mo-kuai/"/>
    <updated>2017-06-14T11:37:33+08:00</updated>
    <id>http://blog.fasionchan.com/blog/2017/06/14/linux-nei-he-mo-kuai</id>
    <content type="html"><![CDATA[<p>Linux内核管理着一台计算机的所有资源，为上层应用程序提供统一的编程接口(系统调用)，屏蔽底层设备的差异。
由于不同用户物理设备以及对内核功能需求的差异性，需要一种类似插件的运行机制——编写插件实现所需功能，然后嵌入到内核中，与内核形成一个整体。</p>

<p><strong>Linux内核模块</strong>便是这样的插件。作为Linux内核的扩展手段，可以在运行时动态加载和卸载。
那么，一个内核模块是怎么编写的呢？与普通程序编写有什么区别呢？</p>

<p>程序开发经常以<code>hello world</code>程序入门，因为这是最简单的。
本文也通过一个最简单的内核模块，演示如何一步步编写一个内核模块。</p>

<!--more-->


<h1>结构</h1>

<p>内核模块与普通程序不同，没有执行流。
可以这样理解，内核模块实现一些函数，作为回调函数注册到内核中。
在内核加载/卸载时，或者其他应用程序调用系统调用时，注册的回调函数才得到调用。</p>

<p>有两个最基本的回调函数<code>init</code>和<code>exit</code>，分别由<code>module_init</code>和<code>module_exit</code>登记，分别在模块加载和卸载的时候执行。
下面实现的<code>hello world</code>内核模块，将只实现这两个最基本的函数。</p>

<p>内核模块支持参数，用户借此控制内核模块的行为。
参数有默认值，可以在加载时指定，也可以在通过<code>proc</code>伪文件系统等手段动态修改。</p>

<p>此外，内核模块还需要带一些描述信息，包括许可证、作者、描述以及版本等等。
描述信息由<code>MODULE_</code>系列宏指定，<code>modinfo</code>等命令可以展示这些信息。</p>

<h1>编码</h1>

<p>开干了！新建一个文件，<code>hello.c</code>用于实现一个玩具型内核模块——<code>hello</code>模块。</p>

<p><code>hello</code>模块只实现<code>init</code>和<code>exit</code>函数，分别在加载和卸载时往内核日志输出一条记录。
同时，也演示了参数的使用方式——通过参数控制日志输出内容。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm"> * FileName:   hello.c</span>
</span><span class='line'><span class="cm"> * Author:     Chen Yanfei</span>
</span><span class='line'><span class="cm"> * @contact:   fasionchan@gmail.com</span>
</span><span class='line'><span class="cm"> * @version:   $Id$</span>
</span><span class='line'><span class="cm"> *</span>
</span><span class='line'><span class="cm"> * Description:</span>
</span><span class='line'><span class="cm"> *</span>
</span><span class='line'><span class="cm"> * Changelog:</span>
</span><span class='line'><span class="cm"> *</span>
</span><span class='line'><span class="cm"> **/</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 引入相关内核头文件</span>
</span><span class='line'><span class="cp">#include &lt;linux/module.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 内核模块信息，包括许可证、作者、描述和版本等</span>
</span><span class='line'><span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
</span><span class='line'><span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Fasion Chan&quot;</span><span class="p">);</span>
</span><span class='line'><span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;An hello worlk module for demonstration&quot;</span><span class="p">);</span>
</span><span class='line'><span class="n">MODULE_VERSION</span><span class="p">(</span><span class="s">&quot;1.0&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 内核模块参数，加载时指定或者动态指定，以此控制模块行为</span>
</span><span class='line'><span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;world&quot;</span><span class="p">;</span>
</span><span class='line'><span class="n">module_param</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">charp</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
</span><span class='line'><span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;Whom this module say hello to&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="c1">// 初始化函数，在加载时调用，分配资源准备执行环境</span>
</span><span class='line'><span class="c1">// 这里只是往内核日志输出一行记录</span>
</span><span class='line'><span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">hello_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;HELLO: Hello %s, this is hello module speaking</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="c1">// 清理函数，在卸载时调用，回收资源销毁执行环境</span>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">hello_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;HELLO: Goodbye %s&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 登记初始化函数及清理函数</span>
</span><span class='line'><span class="n">module_init</span><span class="p">(</span><span class="n">hello_init</span><span class="p">);</span>
</span><span class='line'><span class="n">module_exit</span><span class="p">(</span><span class="n">hello_exit</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<h1>编译</h1>

<p>内核模块代码已经写好了，怎样知道写得对不对呢？编译运行一下不就知道了？
可问题是如何编译呢？跟普通程序一样吗？用<code>gcc</code>来编译？</p>

<p>没错，内核模块用<code>gcc</code>来编译，但不会直接运行<code>gcc</code>。
我们需要先准备一个<code>Makefile</code>，内容如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">obj</span><span class="o">-</span><span class="n">m</span><span class="o">+=</span><span class="n">hello</span><span class="p">.</span><span class="n">o</span>
</span><span class='line'>
</span><span class='line'><span class="nl">all</span><span class="p">:</span>
</span><span class='line'>  <span class="n">make</span> <span class="o">-</span><span class="n">C</span> <span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">modules</span><span class="o">/</span><span class="err">$</span><span class="p">(</span><span class="n">shell</span> <span class="n">uname</span> <span class="o">-</span><span class="n">r</span><span class="p">)</span><span class="o">/</span><span class="n">build</span><span class="o">/</span> <span class="n">M</span><span class="o">=</span><span class="err">$</span><span class="p">(</span><span class="n">PWD</span><span class="p">)</span> <span class="n">modules</span>
</span><span class='line'>
</span><span class='line'><span class="nl">clean</span><span class="p">:</span>
</span><span class='line'>  <span class="n">make</span> <span class="o">-</span><span class="n">C</span> <span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">modules</span><span class="o">/</span><span class="err">$</span><span class="p">(</span><span class="n">shell</span> <span class="n">uname</span> <span class="o">-</span><span class="n">r</span><span class="p">)</span><span class="o">/</span><span class="n">build</span><span class="o">/</span> <span class="n">M</span><span class="o">=</span><span class="err">$</span><span class="p">(</span><span class="n">PWD</span><span class="p">)</span> <span class="n">modules</span>
</span></code></pre></td></tr></table></div></figure>


<p>好了之后，我们再命令行下运行<code>make</code>即可：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="err">$</span> <span class="n">ls</span>
</span><span class='line'><span class="n">hello</span><span class="p">.</span><span class="n">c</span>  <span class="n">Makefile</span>
</span><span class='line'><span class="err">$</span> <span class="n">make</span>
</span><span class='line'><span class="n">make</span> <span class="o">-</span><span class="n">C</span> <span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">modules</span><span class="o">/</span><span class="mf">3.16.0</span><span class="o">-</span><span class="mi">4</span><span class="o">-</span><span class="n">amd64</span><span class="o">/</span><span class="n">build</span><span class="o">/</span> <span class="n">M</span><span class="o">=/</span><span class="n">home</span><span class="o">/</span><span class="n">fasion</span><span class="o">/</span><span class="n">hello</span> <span class="n">modules</span>
</span><span class='line'><span class="n">make</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">:</span> <span class="n">Entering</span> <span class="n">directory</span> <span class="err">&#39;</span><span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">linux</span><span class="o">-</span><span class="n">headers</span><span class="o">-</span><span class="mf">3.16.0</span><span class="o">-</span><span class="mi">4</span><span class="o">-</span><span class="n">amd64</span><span class="err">&#39;</span>
</span><span class='line'><span class="n">make</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">:</span> <span class="n">Entering</span> <span class="n">directory</span> <span class="err">`</span><span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">linux</span><span class="o">-</span><span class="n">headers</span><span class="o">-</span><span class="mf">3.16.0</span><span class="o">-</span><span class="mi">4</span><span class="o">-</span><span class="n">amd64</span><span class="err">&#39;</span>
</span><span class='line'>  <span class="n">CC</span> <span class="p">[</span><span class="n">M</span><span class="p">]</span>  <span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">fasion</span><span class="o">/</span><span class="n">hello</span><span class="o">/</span><span class="n">hello</span><span class="p">.</span><span class="n">o</span>
</span><span class='line'>  <span class="n">Building</span> <span class="n">modules</span><span class="p">,</span> <span class="n">stage</span> <span class="mf">2.</span>
</span><span class='line'>  <span class="n">MODPOST</span> <span class="mi">1</span> <span class="n">modules</span>
</span><span class='line'>  <span class="n">CC</span>      <span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">fasion</span><span class="o">/</span><span class="n">hello</span><span class="o">/</span><span class="n">hello</span><span class="p">.</span><span class="n">mod</span><span class="p">.</span><span class="n">o</span>
</span><span class='line'>  <span class="n">LD</span> <span class="p">[</span><span class="n">M</span><span class="p">]</span>  <span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">fasion</span><span class="o">/</span><span class="n">hello</span><span class="o">/</span><span class="n">hello</span><span class="p">.</span><span class="n">ko</span>
</span><span class='line'><span class="n">make</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">:</span> <span class="n">Leaving</span> <span class="n">directory</span> <span class="err">&#39;</span><span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">linux</span><span class="o">-</span><span class="n">headers</span><span class="o">-</span><span class="mf">3.16.0</span><span class="o">-</span><span class="mi">4</span><span class="o">-</span><span class="n">amd64</span><span class="err">&#39;</span>
</span><span class='line'><span class="err">$</span> <span class="n">ls</span>
</span><span class='line'><span class="n">hello</span><span class="p">.</span><span class="n">c</span>  <span class="n">hello</span><span class="p">.</span><span class="n">ko</span>  <span class="n">hello</span><span class="p">.</span><span class="n">mod</span><span class="p">.</span><span class="n">c</span>  <span class="n">hello</span><span class="p">.</span><span class="n">mod</span><span class="p">.</span><span class="n">o</span>  <span class="n">hello</span><span class="p">.</span><span class="n">o</span>  <span class="n">Makefile</span>  <span class="n">modules</span><span class="p">.</span><span class="n">order</span>  <span class="n">Module</span><span class="p">.</span><span class="n">symvers</span>
</span></code></pre></td></tr></table></div></figure>


<p>看到<code>hello.ko</code>文件生成，意味着编译大功告成了！
该文件就是二进制内核模块目标文件，其他文件的作用不再讨论了。</p>

<p>顺便提一句，<code>Makefile</code>中分成<code>all</code>和<code>clean</code>两节。
其中<code>all</code>用来编译，<code>clean</code>用来清理编译环境：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="err">$</span> <span class="n">make</span> <span class="n">clean</span>
</span><span class='line'><span class="n">make</span> <span class="o">-</span><span class="n">C</span> <span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">modules</span><span class="o">/</span><span class="mf">3.16.0</span><span class="o">-</span><span class="mi">4</span><span class="o">-</span><span class="n">amd64</span><span class="o">/</span><span class="n">build</span><span class="o">/</span> <span class="n">M</span><span class="o">=/</span><span class="n">home</span><span class="o">/</span><span class="n">fasion</span><span class="o">/</span><span class="n">hello</span> <span class="n">clean</span>
</span><span class='line'><span class="n">make</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">:</span> <span class="n">Entering</span> <span class="n">directory</span> <span class="err">&#39;</span><span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">linux</span><span class="o">-</span><span class="n">headers</span><span class="o">-</span><span class="mf">3.16.0</span><span class="o">-</span><span class="mi">4</span><span class="o">-</span><span class="n">amd64</span><span class="err">&#39;</span>
</span><span class='line'><span class="n">make</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">:</span> <span class="n">Entering</span> <span class="n">directory</span> <span class="err">`</span><span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">linux</span><span class="o">-</span><span class="n">headers</span><span class="o">-</span><span class="mf">3.16.0</span><span class="o">-</span><span class="mi">4</span><span class="o">-</span><span class="n">amd64</span><span class="err">&#39;</span>
</span><span class='line'>  <span class="n">CLEAN</span>   <span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">fasion</span><span class="o">/</span><span class="n">hello</span><span class="o">/</span><span class="p">.</span><span class="n">tmp_versions</span>
</span><span class='line'>  <span class="n">CLEAN</span>   <span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">fasion</span><span class="o">/</span><span class="n">hello</span><span class="o">/</span><span class="n">Module</span><span class="p">.</span><span class="n">symvers</span>
</span><span class='line'><span class="n">make</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">:</span> <span class="n">Leaving</span> <span class="n">directory</span> <span class="err">&#39;</span><span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">linux</span><span class="o">-</span><span class="n">headers</span><span class="o">-</span><span class="mf">3.16.0</span><span class="o">-</span><span class="mi">4</span><span class="o">-</span><span class="n">amd64</span><span class="err">&#39;</span>
</span><span class='line'><span class="err">$</span> <span class="n">ls</span>
</span><span class='line'><span class="n">hello</span><span class="p">.</span><span class="n">c</span>  <span class="n">Makefile</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以看到，运行了<code>make clean</code>后，所有编译生成的文件都清理掉了，只剩源码文件和<code>Makefile</code>。</p>

<h1>运行</h1>

<p>内核模块编译完成后，要怎么使用呢？跟普通程序直接运行不同，内核模块需要加载到内核里面发挥作用。使用<code>insmod</code>命令加载内核模块：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="err">$</span> <span class="n">ls</span>
</span><span class='line'><span class="n">hello</span><span class="p">.</span><span class="n">c</span>  <span class="n">hello</span><span class="p">.</span><span class="n">ko</span>  <span class="n">hello</span><span class="p">.</span><span class="n">mod</span><span class="p">.</span><span class="n">c</span>  <span class="n">hello</span><span class="p">.</span><span class="n">mod</span><span class="p">.</span><span class="n">o</span>  <span class="n">hello</span><span class="p">.</span><span class="n">o</span>  <span class="n">Makefile</span>  <span class="n">modules</span><span class="p">.</span><span class="n">order</span>  <span class="n">Module</span><span class="p">.</span><span class="n">symvers</span>
</span><span class='line'><span class="err">$</span> <span class="n">sudo</span> <span class="n">insmod</span> <span class="n">hello</span><span class="p">.</span><span class="n">ko</span>
</span><span class='line'><span class="err">$</span> <span class="n">dmesg</span>
</span><span class='line'><span class="p">[</span>   <span class="mf">14.226777</span><span class="p">]</span> <span class="mo">00</span><span class="o">:</span><span class="mo">00</span><span class="o">:</span><span class="mf">00.000718</span> <span class="n">main</span>     <span class="n">OS</span> <span class="nl">Product</span><span class="p">:</span> <span class="n">Linux</span>
</span><span class='line'><span class="p">[</span>   <span class="mf">14.226814</span><span class="p">]</span> <span class="mo">00</span><span class="o">:</span><span class="mo">00</span><span class="o">:</span><span class="mf">00.000779</span> <span class="n">main</span>     <span class="n">OS</span> <span class="nl">Release</span><span class="p">:</span> <span class="mf">3.16.0</span><span class="o">-</span><span class="mi">4</span><span class="o">-</span><span class="n">amd64</span>
</span><span class='line'><span class="p">[</span>   <span class="mf">14.226845</span><span class="p">]</span> <span class="mo">00</span><span class="o">:</span><span class="mo">00</span><span class="o">:</span><span class="mf">00.000814</span> <span class="n">main</span>     <span class="n">OS</span> <span class="nl">Version</span><span class="p">:</span> <span class="err">#</span><span class="mi">1</span> <span class="n">SMP</span> <span class="n">Debian</span> <span class="mf">3.16.7</span><span class="o">-</span><span class="n">ckt20</span><span class="o">-</span><span class="mi">1</span><span class="o">+</span><span class="n">deb8u4</span> <span class="p">(</span><span class="mi">2016</span><span class="o">-</span><span class="mo">02</span><span class="o">-</span><span class="mi">29</span><span class="p">)</span>
</span><span class='line'><span class="p">[</span>   <span class="mf">14.226873</span><span class="p">]</span> <span class="mo">00</span><span class="o">:</span><span class="mo">00</span><span class="o">:</span><span class="mf">00.000844</span> <span class="n">main</span>     <span class="n">OS</span> <span class="n">Service</span> <span class="nl">Pack</span><span class="p">:</span> <span class="err">#</span><span class="mi">1</span> <span class="n">SMP</span> <span class="n">Debian</span> <span class="mf">3.16.7</span><span class="o">-</span><span class="n">ckt20</span><span class="o">-</span><span class="mi">1</span><span class="o">+</span><span class="n">deb8u4</span> <span class="p">(</span><span class="mi">2016</span><span class="o">-</span><span class="mo">02</span><span class="o">-</span><span class="mi">29</span><span class="p">)</span>
</span><span class='line'><span class="p">[</span>   <span class="mf">14.226912</span><span class="p">]</span> <span class="mo">00</span><span class="o">:</span><span class="mo">00</span><span class="o">:</span><span class="mf">00.000872</span> <span class="n">main</span>     <span class="nl">Executable</span><span class="p">:</span> <span class="o">/</span><span class="n">opt</span><span class="o">/</span><span class="n">VBoxGuestAdditions</span><span class="o">-</span><span class="mf">5.0.8</span><span class="o">/</span><span class="n">sbin</span><span class="o">/</span><span class="n">VBoxService</span>
</span><span class='line'><span class="mo">00</span><span class="o">:</span><span class="mo">00</span><span class="o">:</span><span class="mf">00.000873</span> <span class="n">main</span>     <span class="n">Process</span> <span class="nl">ID</span><span class="p">:</span> <span class="mi">716</span>
</span><span class='line'><span class="mo">00</span><span class="o">:</span><span class="mo">00</span><span class="o">:</span><span class="mf">00.000874</span> <span class="n">main</span>     <span class="n">Package</span> <span class="nl">type</span><span class="p">:</span> <span class="n">LINUX_64BITS_GENERIC</span>
</span><span class='line'><span class="p">[</span>   <span class="mf">14.232015</span><span class="p">]</span> <span class="mo">00</span><span class="o">:</span><span class="mo">00</span><span class="o">:</span><span class="mf">00.005962</span> <span class="n">main</span>     <span class="mf">5.0.8</span> <span class="n">r103449</span> <span class="n">started</span><span class="p">.</span> <span class="n">Verbose</span> <span class="n">level</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'><span class="p">[</span> <span class="mf">4368.359895</span><span class="p">]</span> <span class="nl">HELLO</span><span class="p">:</span> <span class="n">Hello</span> <span class="n">world</span><span class="p">,</span> <span class="n">this</span> <span class="n">is</span> <span class="n">hello</span> <span class="n">module</span> <span class="n">speaking</span>
</span></code></pre></td></tr></table></div></figure>


<p>内核模块加载后，用<code>dmesg</code>命令看到，内核模块初始化时输出的一条内核日志。</p>

<p>加载内核模块时怎么指定参数的值呢？下面演示移除内核模块，并以<code>fasion</code>为<code>name</code>参数值重新挂载：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="err">$</span> <span class="n">sudo</span> <span class="n">rmmod</span> <span class="n">hello</span>
</span><span class='line'><span class="err">$</span> <span class="n">sudo</span> <span class="n">insmod</span> <span class="n">hello</span><span class="p">.</span><span class="n">ko</span> <span class="n">name</span><span class="o">=</span><span class="n">fasion</span>
</span></code></pre></td></tr></table></div></figure>


<p>操作完成后，用<code>dmesg</code>可以看到以下内核日志：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="p">[</span> <span class="mf">4368.359895</span><span class="p">]</span> <span class="nl">HELLO</span><span class="p">:</span> <span class="n">Hello</span> <span class="n">world</span><span class="p">,</span> <span class="n">this</span> <span class="n">is</span> <span class="n">hello</span> <span class="n">module</span> <span class="n">speaking</span>
</span><span class='line'><span class="p">[</span> <span class="mf">4812.067761</span><span class="p">]</span> <span class="nl">HELLO</span><span class="p">:</span> <span class="n">Goodbye</span> <span class="n">world</span>
</span><span class='line'><span class="p">[</span> <span class="mf">4841.011892</span><span class="p">]</span> <span class="nl">HELLO</span><span class="p">:</span> <span class="n">Hello</span> <span class="n">fasion</span><span class="p">,</span> <span class="n">this</span> <span class="n">is</span> <span class="n">hello</span> <span class="n">module</span> <span class="n">speaking</span>
</span></code></pre></td></tr></table></div></figure>


<p>第二次挂载时，<code>name</code>参数的值不是默认值<code>world</code>，而是<code>fasion</code>了。</p>

<p>跟内核模块相关还有<code>insmod</code>、<code>rmmod</code>、<code>lsmod</code>、<code>modinfo</code>、<code>modprobe</code>等命令，用法请参考<code>man</code>文档。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[译文]MongoDB WiredTiger引擎调优技巧]]></title>
    <link href="http://blog.fasionchan.com/blog/2017/03/09/yi-wen-mongodb-wiredtiger-yin-qing-tiao-you-ji-qiao/"/>
    <updated>2017-03-09T18:44:40+08:00</updated>
    <id>http://blog.fasionchan.com/blog/2017/03/09/yi-wen-mongodb-wiredtiger-yin-qing-tiao-you-ji-qiao</id>
    <content type="html"><![CDATA[<p><code>MongoDB</code>从<code>3.0</code>开始引入可插拔存储引擎的概念。
当前，有不少存储引擎可供选择：<code>MMAPV1</code>、<code>WiredTiger</code>、<code>MongoRocks</code>、<code>TokuSE</code>等等。
每个存储引擎都有自己的优势，你需要根据性能要求及应用特征挑选最适合的一个。</p>

<p>从<code>3.2.x</code>开始，<code>WiredTiger</code>成为默认的存储引擎。
最为<code>MongoDB</code>目前最流行的存储引擎，<code>WiredTiger</code>与原先的<code>MMAPV1</code>相比有以下优势：</p>

<ul>
<li><strong>性能&amp;并发</strong>：在大多数工作负载下，<code>WiredTiger</code>的性能要比<code>MMAPV1</code>高很多。
<code>WiredTiger</code>引擎为现代多核系统量身定制，更好地发挥多核系统的处理能力。
<code>MMAPV1</code>引擎使用表级锁，因此，当某个单表上有并发的操作，吞吐将受到限制。
<code>WiredTiger</code>使用文档级锁，由此带来并发及吞吐的提高。
对于典型的应用，切到<code>WiredTiger</code>引擎，可带来5-10倍的性能提升。</li>
</ul>


<!--more-->


<ul>
<li><p><strong>压缩&amp;加密</strong>：<code>MMAPV1</code>引擎要求数据在内存和在磁盘的形式一致(map磁盘内存映射)。
因此，它并不支持压缩和加密。<code>WiredTiger</code>并没有这层限制，可以更好地支持。</p></li>
<li><p><strong>索引前缀压缩</strong>：<code>WiredTiger</code>存储索引时使用前缀压缩——相同的前缀只存一次。
由此带来的效果是：索引更小了，对物理内存使用也更少了。</p></li>
</ul>


<p>接下来，我会展示几个用来调优<code>WiredTiger</code>引擎性能的关键参数。</p>

<h1>调优Cache Size</h1>

<p><code>WiredTiger</code>最重要的调优参数就是<code>cache</code>规模。
默认，<code>MongoDB</code>从<code>3.x</code>开始会保留可用物理内存的50%(<code>3.2</code>是60%)作为数据<code>cache</code>。
虽然，默认的设置可以应对大部分的应用，通过调节为特定应用找到最佳配置值还是非常值得的。
<code>cache</code>的规模必须足够大，以便保存应用整个工作集(working set)。</p>

<p>除了这个<code>cache</code>，<code>MongoDB</code>在做诸如聚合、排序、连接管理等操作时需要额外的内存。
因此，必须确保有足够的内存可供使用，否则，<code>MongoDB</code>进程有被<code>OOM killer</code>杀死的风险。</p>

<p>调节这个参数，首先要理解在默认配置下，<code>cache</code>的使用情况。运行以下命令，可以获得<code>cache</code>统计：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>db.serverStatus().wiredTiger.cache</span></code></pre></td></tr></table></div></figure>


<p>命令输出结果例子如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>   "tracked dirty bytes in the cache" : 409861,
</span><span class='line'>   "tracked bytes belonging to internal pages in the cache" : 738956332,
</span><span class='line'>   "bytes currently in the cache" : 25769360777,
</span><span class='line'>   "tracked bytes belonging to leaf pages in the cache" : 31473298388,
</span><span class='line'>   "maximum bytes configured" : 32212254720,
</span><span class='line'>   "tracked bytes belonging to overflow pages in the cache" : 0,
</span><span class='line'>   "bytes read into cache" : 29628550664,
</span><span class='line'>   "bytes written from cache" : 34634778285,
</span><span class='line'>   "pages evicted by application threads" : 0,
</span><span class='line'>   "checkpoint blocked page eviction" : 102,
</span><span class='line'>   "unmodified pages evicted" : 333277,
</span><span class='line'>   "page split during eviction deepened the tree" : 0,
</span><span class='line'>   "modified pages evicted" : 437117,
</span><span class='line'>   "pages selected for eviction unable to be evicted" : 44825,
</span><span class='line'>   "pages evicted because they exceeded the in-memory maximum" : 74,
</span><span class='line'>   "pages evicted because they had chains of deleted items" : 33725,
</span><span class='line'>   "failed eviction of pages that exceeded the in-memory maximum" : 1518,
</span><span class='line'>   "hazard pointer blocked page eviction" : 34814,
</span><span class='line'>   "internal pages evicted" : 21623,
</span><span class='line'>   "maximum page size at eviction" : 10486876,
</span><span class='line'>   "eviction server candidate queue empty when topping up" : 8235,
</span><span class='line'>   "eviction server candidate queue not empty when topping up" : 3020,
</span><span class='line'>   "eviction server evicting pages" : 191708,
</span><span class='line'>   "eviction server populating queue, but not evicting pages" : 2996,
</span><span class='line'>   "eviction server unable to reach eviction goal" : 0,
</span><span class='line'>   "pages split during eviction" : 8821,
</span><span class='line'>   "pages walked for eviction" : 157970002,
</span><span class='line'>   "eviction worker thread evicting pages" : 563015,
</span><span class='line'>   "in-memory page splits" : 52,
</span><span class='line'>   "percentage overhead" : 8,
</span><span class='line'>   "tracked dirty pages in the cache" : 9,
</span><span class='line'>   "pages currently held in the cache" : 1499798,
</span><span class='line'>   "pages read into cache" : 2260232,
</span><span class='line'>   "pages written from cache" : 3018846
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>第一个要关注的数值试，<code>cache</code>中脏数据的百分比。
如果这个百分比比较高，那么调大<code>cache</code>规模很有可能可以提升性能。
如果应用是重读的，可再关注<code>bytes read into cache</code>这个指标。
如果这个指标比较高，那么调大<code>cache</code>规模很有可能可以提升读性能。</p>

<p>调节<code>cache</code>规模不一定非得重启服务，我们可以动态调整：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>db.adminCommand( { "setParameter": 1, "wiredTigerEngineRuntimeConfig": "cache_size=xxG"})</span></code></pre></td></tr></table></div></figure>


<p>如果你想让调整在重启后也有效，那么你需要将配置文件也相应调整一下。</p>

<h1>控制Read/Write Tickets</h1>

<p>WiredTiger使用<code>tickets</code>来控制可以同时被存储引擎处理的读/写操作数。
默认值是128，在大部分情况下表现良好。
如果这个值经常掉到0，所有后续操作将会被排队等待。
例如，观察到读<code>tickets</code>下降，系统可能有大量长耗时的操作(未索引操作)。
如果你想找出有哪些慢操作，可以用一些第三方工具。
你可以根据系统需要和性能影响上下调节<code>tickets</code>。</p>

<p>运行以下命令可以确认<code>tickets</code>的使用情况：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>db.serverStatus().wiredTiger.concurrentTransactions</span></code></pre></td></tr></table></div></figure>


<p>下面是一个输出例子：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>   "write" : {
</span><span class='line'>      "out" : 0,
</span><span class='line'>      "available" : 128,
</span><span class='line'>      "totalTickets" : 128
</span><span class='line'>   },
</span><span class='line'>   "read" : {
</span><span class='line'>      "out" : 3,
</span><span class='line'>      "available" : 128,
</span><span class='line'>      "totalTickets" : 128
</span><span class='line'>   }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>同样，可以动态调节<code>tickets</code>：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>db.adminCommand( { setParameter: 1, wiredTigerConcurrentReadTransactions: xx } )
</span><span class='line'>db.adminCommand( { setParameter: 1, wiredTigerConcurrentWriteTransactions: xx } )</span></code></pre></td></tr></table></div></figure>


<p>一旦做出调整，注意要观察系统的性能监控确保影响是符合预期的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[打造炫酷的开发环境]]></title>
    <link href="http://blog.fasionchan.com/blog/2016/12/17/da-zao-xuan-ku-de-kai-fa-huan-jing/"/>
    <updated>2016-12-17T21:20:34+08:00</updated>
    <id>http://blog.fasionchan.com/blog/2016/12/17/da-zao-xuan-ku-de-kai-fa-huan-jing</id>
    <content type="html"><![CDATA[<p>无图无真相，这篇文章的主要目的是打造如下所示的终端开发环境，涉及<code>terminal</code>、<code>shell</code>以及<code>editor</code>等，着重于配色。</p>

<p><img src="http://blog.fasionchan.com/images/zsh.png"></p>

<!--more-->


<p><code>terminal</code>不必多说，<code>iTerm2</code>是<code>Mac</code>下的不二选择，不解释了。如果你在<code>windows</code>上开发，推荐使用<code>Putty</code>，当然了跟<code>iTerm2</code>不是同个级别的东西。</p>

<p>关于<code>shell</code>，我之前一直在<code>bash</code>上瞎折腾，认为最普适的就是最好的。毕竟在绝大多数机器环境上，<code>bash</code>唾手可得，不需要额外安装。但是，<code>bash</code>没有足够丰富的现成配置方案可用，自己山寨要花很多精力而且效果也不是很好。<code>zsh</code>就不一样，名字就透着<code>shell</code>终结者的意思。<code>zsh</code>比<code>bash</code>要好用，而且有现成的配置方案，特别是<code>oh-my-zsh</code>，非常好用。</p>

<p><img src="http://blog.fasionchan.com/images/vim.png"></p>

<p>关于<code>editor</code>，向来都有<code>vim</code>或<code>emacs</code>的争议。我只使用过<code>vim</code>，也没法评论。争议是没有必要的，如果都没用过，选一个学一下就是；如果用过其中之一，维持现状即可；想两个都体验一下也行，找到适合自己的才是最重要的。我习惯使用<code>vim</code>，下文便以<code>vim</code>为例好了。</p>

<h1>iTerm2</h1>

<p><code>iTerm2</code>是<code>Mac</code>下一款优秀的终端软件，功能比内置的<code>iTerm</code>强很多。关键是，这款应用还是免费的！赶紧到<a href="https://www%0A.iterm2.com/">www.iterm2.com</a>下载吧！安装后，它是这个样子的：</p>

<p><img src="http://blog.fasionchan.com/images/iterm2-default.png"></p>

<p>呃，颜色货不对版呀！对的，这是<code>iTerm2</code>默认的颜色，别心急，接下来我们来调整配色方案。</p>

<h2>配色</h2>

<p><a href="http://ethanschoonover.com/solarized">solarized</a>是一套好看又不伤眼的配置方案，很多人推荐，目前托管在<a href="https://github.com/altercation/solarized">github</a>上。接下来，我们看看怎么给<code>iTerm2</code>加上<code>solarized</code>配色。</p>

<p>首先，将<code>solarized</code>下载到本地：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git clone git@github.com:altercation/solarized.git</span></code></pre></td></tr></table></div></figure>


<p>可以看到，里面包罗万象，这里我们要使用的是<code>iterm2-colors-solarized</code>目录下的，包括<code>Solarized Dark.itermcolors</code>和<code>Solarized Light.itermcolors</code>两个配置文件。</p>

<p><img src="http://blog.fasionchan.com/images/iterm2-color.png"></p>

<p>打开<code>Preferences-&gt;Profiles-&gt;Color</code>面板，在<code>Color Presets</code>中将以上两个配置方案导入，然后选择<code>Solarized Dark</code>或者<code>Solarized Light</code>即可。一般推荐使用<code>Solarized Dark</code>，<code>Solarized Light</code>有种亮瞎的感觉。配色搞定后，终端是这样子的：</p>

<p><img src="http://blog.fasionchan.com/images/iterm2-solarized.png"></p>

<p>看着这样柔和的颜色，眼睛就不会很容易就累了。</p>

<h1>zsh</h1>

<p><code>shell</code>提示符高亮及<code>git</code>代码状态展示是怎么实现的呢？这就要说到强大的<code>zsh</code>了。不废话，<code>Mac</code>下应该是内置的了；<code>Linux</code>下运行<code>apt-get install zsh</code>即可安装；<code>Windows</code>下烫烫烫烫烫。</p>

<h2>配置</h2>

<p>接下来，用<a href="https://github.com/robbyrussell/oh-my-zsh">oh-my-zsh</a>来武装<code>zsh</code>，一行命令搞定：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sh -c "$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)"</span></code></pre></td></tr></table></div></figure>


<h2>主题</h2>

<p><code>oh-my-zsh</code>中提供了多套主题可供选择，有不同的输出样式及配色。默认应该是<a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Themes#robbyrussell">robbyrussell</a>，感觉中规中矩没啥亮点。翻看了一下，发现了<a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Themes#agnoster">agnoster</a>主题，感觉非常入眼。</p>

<p>接下来，编辑<code>~/.zshrc</code>，找到变量<code>ZSH_THEME</code>将其赋值改为<code>agnoster</code>即可。操作完毕，发现离目标很近了：</p>

<p><img src="http://blog.fasionchan.com/images/zsh-font-fault.png"></p>

<p>除了有些字体显示异常，什么鬼？</p>

<h2>字体</h2>

<p>为了显示正常，需要安装<code>powerline</code>字体，方法如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git clone git@github.com:powerline/fonts.git
</span><span class='line'>cd fonts
</span><span class='line'>./install</span></code></pre></td></tr></table></div></figure>


<p>然后，在<code>iTerm2-&gt;Preferences-&gt;Profiles-&gt;Text</code>面板中将<code>Non-ASCII Font</code>改成<code>Roboto Mono Powerline</code>，显示就正常了！</p>

<p><img src="http://blog.fasionchan.com/images/iterm2-text.png"></p>

<h1>vim</h1>

<p> <code>vim</code>配置这个话题有点大，包括：代码静态检查、高亮、文件树等等。理论上，通过插件，可以将<code>vim</code>打造成一个<code>IDE</code>，后续有空专门介绍一下。这节聚焦在：<code>vim</code>配色主题。</p>

<p>这里还是使用<code>solarized</code>配色方案：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>mkdir -p ~/.vim/colors
</span><span class='line'>cd solarized
</span><span class='line'>cp vim-colors-solarized/colors/solarized.vim ~/.vim/colors/</span></code></pre></td></tr></table></div></figure>


<p>编辑<code>~/.vimrc</code>文件，加上：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>syntax enable
</span><span class='line'>set background=dark
</span><span class='line'>colorscheme solarized</span></code></pre></td></tr></table></div></figure>


<p>这样，打开<code>vim</code>看到的就是文件开头图片显示的效果了。</p>

<h1>自动化配置</h1>

<p>如果只在自己的电脑上配置，手工操作一遍是没有问题的。但是，现实是，每个人可能都有多个不同的开发环境：自己的<code>PC</code>、公司的<code>PC</code>、线上的机器等等。每台机器都这样手工配置一遍，繁琐而且容易出错，感觉不敢想。</p>

<p>程序猿是一种有懒癌的动物，一件事情绝不重复做第二遍。如果，可以将以上配置操作脚本化，在一个新的机器环境，跑一下脚本就搞定一切，那多好！这就是我维护一个<code>conf</code>代码仓库的初衷。</p>

<p><code>conf</code>提供一个脚本，<code>install</code>用来按照各种配置。比如，运行以下命令，<code>zsh</code>和<code>vim</code>的配置就安装完毕了。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cd conf
</span><span class='line'>./install zsh
</span><span class='line'>./install vim</span></code></pre></td></tr></table></div></figure>


<p>当然了，<code>conf</code>完全是按照我个人的喜好定制的，可能并不适合你。尽管如此，你可以参考它打造属于自己的自动化配置工具。<strong>时间应该用来做有趣的事情，而不是浪费在简单的重复中</strong>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[更优雅地造测试数据]]></title>
    <link href="http://blog.fasionchan.com/blog/2016/12/11/geng-you-ya-di-zao-ce-shi-shu-ju/"/>
    <updated>2016-12-11T09:57:52+08:00</updated>
    <id>http://blog.fasionchan.com/blog/2016/12/11/geng-you-ya-di-zao-ce-shi-shu-ju</id>
    <content type="html"><![CDATA[<p>开发系统时，经常需要一些伪数据用于测试。举个例子，设计一个学生管理系统，测试注册功能，总需要一些用户信息吧。我猜大部分人都会填：用户<code>aaaa</code>，密码<code>1111</code>，手机号码<code>1111</code>……感觉略无追求~</p>

<p>那么有没有办法造一个看上是真的数据呢？肯定是有的——人是活的嘛~</p>

<p>自己造很累，有没有不需要大脑的方法的？还真有，这就是本文要介绍的一个<code>Python</code>模块——<a href="https://pypi.python.org/pypi/fake-factory">Faker</a>。</p>

<!--more-->


<h1>安装</h1>

<p>其实，这节可以不必说，<code>Python</code>装包无非就<code>pip</code>嘛：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pip install Faker</span></code></pre></td></tr></table></div></figure>


<h1>快速入手</h1>

<p>生成数据前需要先初始化一个生成器，有两种方式可以完成：①用<code>faker.Factory.create()</code>；②用<code>faker.Faker()</code>。</p>

<figure class='code'><figcaption><span>快速入手</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">from</span> <span class="nn">faker</span> <span class="kn">import</span> <span class="n">Factory</span>
</span><span class='line'><span class="n">fake</span> <span class="o">=</span> <span class="n">Factory</span><span class="o">.</span><span class="n">create</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'><span class="c"># OR</span>
</span><span class='line'><span class="kn">from</span> <span class="nn">faker</span> <span class="kn">import</span> <span class="n">Faker</span>
</span><span class='line'><span class="n">fake</span> <span class="o">=</span> <span class="n">Faker</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'><span class="n">fake</span><span class="o">.</span><span class="n">name</span><span class="p">()</span>
</span><span class='line'><span class="c"># &#39;Lucy Cechtelar&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="n">fake</span><span class="o">.</span><span class="n">address</span><span class="p">()</span>
</span><span class='line'><span class="c"># &quot;426 Jordy Lodge# Cartwrightshire, SC 88120-6700&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="n">fake</span><span class="o">.</span><span class="n">text</span><span class="p">()</span>
</span><span class='line'><span class="c"># Sint velit eveniet. Rerum atque repellat voluptatem quia rerum. Numquam excepturi# beatae sint laudantium consequatur. Magni occaecati itaque sint et sit tempore. Nesciunt# amet quidem. Iusto deleniti cum autem ad quia aperiam.# A consectetur quos aliquam. In iste aliquid et aut similique suscipit. Consequatur qui# quaerat iste minus hic expedita. Consequuntur error magni et laboriosam. Aut aspernatur# voluptatem sit aliquam. Dolores voluptatum est.# Aut molestias et maxime. Fugit autem facilis quos vero. Eius quibusdam possimus est.# Ea quaerat et quisquam. Deleniti sunt quam. Adipisci consequatur id in occaecati.# Et sint et. Ut ducimus quod nemo ab voluptatum.</span>
</span></code></pre></td></tr></table></div></figure>


<p>看看自动化的威力！批量生成，每次都是随机的哦！</p>

<figure class='code'><figcaption><span>批量生成</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">):</span>
</span><span class='line'>    <span class="k">print</span> <span class="n">fake</span><span class="o">.</span><span class="n">name</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'><span class="c"># Adaline Reichel</span>
</span><span class='line'><span class="c"># Dr. Santa Prosacco DVM</span>
</span><span class='line'><span class="c"># Noemy Vandervort V</span>
</span><span class='line'><span class="c"># Lexi O&#39;Conner</span>
</span><span class='line'><span class="c"># Gracie Weber</span>
</span><span class='line'><span class="c"># Roscoe Johns</span>
</span><span class='line'><span class="c"># Emmett Lebsack</span>
</span><span class='line'><span class="c"># Keegan Thiel</span>
</span><span class='line'><span class="c"># Wellington Koelpin II</span>
</span><span class='line'><span class="c"># Ms. Karley Kiehn V</span>
</span></code></pre></td></tr></table></div></figure>


<h1>本地化</h1>

<p>你可能会说，这个玩意儿太洋气了——生成一堆英文名字地址啥的有毛用？确实，在计算机领域，英文有天生优势。</p>

<p>但是，重点来了——<code>Faker</code>还支持本地化，真是天地良心！一起来看看怎么生成中文信息吧：</p>

<figure class='code'><figcaption><span>本地化</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">from</span> <span class="nn">faker</span> <span class="kn">import</span> <span class="n">Factory</span>
</span><span class='line'><span class="n">fake</span> <span class="o">=</span> <span class="n">Factory</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="s">&#39;zh_CN&#39;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">):</span>
</span><span class='line'>    <span class="k">print</span> <span class="n">fake</span><span class="o">.</span><span class="n">name</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'><span class="c"># 於涛</span>
</span><span class='line'><span class="c"># 万静</span>
</span><span class='line'><span class="c"># 孙秀荣</span>
</span><span class='line'><span class="c"># 丘辉</span>
</span><span class='line'><span class="c"># 方玉</span>
</span><span class='line'><span class="c"># 虞建国</span>
</span><span class='line'><span class="c"># 丘丽丽</span>
</span><span class='line'><span class="c"># 郭杨</span>
</span><span class='line'><span class="c"># 江欣</span>
</span><span class='line'><span class="c"># 狐龙</span>
</span><span class='line'>
</span><span class='line'><span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">):</span>
</span><span class='line'>    <span class="k">print</span> <span class="n">fake</span><span class="o">.</span><span class="n">address</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'><span class="c"># 杰市戚路d座 855521</span>
</span><span class='line'><span class="c"># 丽华市魏街e座 800775</span>
</span><span class='line'><span class="c"># 坤市莘路P座 376919</span>
</span><span class='line'><span class="c"># 秀云市温街s座 518607</span>
</span><span class='line'><span class="c"># 晨市季街Z座 931186</span>
</span><span class='line'><span class="c"># 丽市夹路N座 670627</span>
</span><span class='line'><span class="c"># 坤市漆街k座 968075</span>
</span><span class='line'><span class="c"># 瑞市於街z座 168689</span>
</span><span class='line'><span class="c"># 金凤市雍路E座 148292</span>
</span><span class='line'><span class="c"># 晨市黎路R座 916369</span>
</span></code></pre></td></tr></table></div></figure>


<h1>高级用法</h1>

<h2>功能扩展</h2>

<p><code>Faker</code>已经提供了足够丰富的信息生成，包括名字、手机号、邮箱地址、邮编等等。尽管如此，可能还是没有办法满足你的需求。这时，你可以自己动手，丰衣足食。下面，我们通过一个例子看看怎么扩展<code>Faker</code>的功能吧：</p>

<figure class='code'><figcaption><span>功能扩展</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">from</span> <span class="nn">faker</span> <span class="kn">import</span> <span class="n">Faker</span>
</span><span class='line'><span class="n">fake</span> <span class="o">=</span> <span class="n">Faker</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'><span class="c"># first, import a similar Provider or use the default one</span>
</span><span class='line'><span class="kn">from</span> <span class="nn">faker.providers</span> <span class="kn">import</span> <span class="n">BaseProvider</span>
</span><span class='line'><span class="c"># create new provider class</span>
</span><span class='line'><span class="k">class</span> <span class="nc">MyProvider</span><span class="p">(</span><span class="n">BaseProvider</span><span class="p">):</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="k">return</span> <span class="s">&#39;bar&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="c"># then add new provider to faker instance</span>
</span><span class='line'><span class="n">fake</span><span class="o">.</span><span class="n">add_provider</span><span class="p">(</span><span class="n">MyProvider</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c"># now you can use:</span>
</span><span class='line'><span class="n">fake</span><span class="o">.</span><span class="n">foo</span><span class="p">()</span>
</span><span class='line'><span class="o">&gt;</span> <span class="s">&#39;bar&#39;</span>
</span></code></pre></td></tr></table></div></figure>


<h2>随机控制</h2>

<p><code>Faker</code>随机生成由<code>random.Random</code>驱动。其中，<code>.random</code>属性返回<code>random.Random</code>对象。通过对该对象的操作，可以实现自定义的行为。</p>

<figure class='code'><figcaption><span>随机对象</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">from</span> <span class="nn">faker</span> <span class="kn">import</span> <span class="n">Faker</span>
</span><span class='line'><span class="n">fake</span> <span class="o">=</span> <span class="n">Faker</span><span class="p">()</span>
</span><span class='line'><span class="n">fake</span><span class="o">.</span><span class="n">random</span>
</span><span class='line'><span class="n">fake</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">getstate</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>那么，可以实现什么自定义呢？举个例子，我们可以设置<code>seed</code>。<code>seed</code>在随机数生成逻辑中什么作用，估计大家都清楚。比如，通过给定<code>seed</code>可以控制每次生成的内容都是一样的：</p>

<figure class='code'><figcaption><span>设置seed</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">from</span> <span class="nn">faker</span> <span class="kn">import</span> <span class="n">Faker</span>
</span><span class='line'><span class="n">fake</span> <span class="o">=</span> <span class="n">Faker</span><span class="p">()</span>
</span><span class='line'><span class="n">faker</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">4321</span><span class="p">)</span>
</span><span class='line'><span class="k">print</span> <span class="n">fake</span><span class="o">.</span><span class="n">name</span><span class="p">()</span>
</span><span class='line'><span class="c"># Margaret Boehm</span>
</span></code></pre></td></tr></table></div></figure>


<p>还有等价写法哦：</p>

<figure class='code'><figcaption><span>设置seed</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">from</span> <span class="nn">faker</span> <span class="kn">import</span> <span class="n">Faker</span>
</span><span class='line'><span class="n">fake</span> <span class="o">=</span> <span class="n">Faker</span><span class="p">()</span>
</span><span class='line'><span class="n">fake</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">4321</span><span class="p">)</span>
</span><span class='line'><span class="k">print</span> <span class="n">fake</span><span class="o">.</span><span class="n">name</span><span class="p">()</span>
</span><span class='line'><span class="c"># Margaret Boehm</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意到，不同的两次运行，只要<code>seed</code>一样，生成出来的信息就是一样的。</p>

<h2>命令行生成</h2>

<p>有时想在<code>shell</code>或者其他程序中生成一些伪数据，是不是一定要写一个<code>Python</code>脚本呢？别急——<code>Faker</code>提供了一个命令行工具，估计可以应对大部分场景了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>faker address
</span><span class='line'><span class="m">968</span> Bahringer Garden Apt. 722Kristinaland, NJ 09890
</span><span class='line'>
</span><span class='line'><span class="nv">$ </span>faker -l de_DE address
</span><span class='line'>Samira-Niemeier-Allee <span class="m">5694812</span> Biedenkopf
</span><span class='line'>
</span><span class='line'><span class="nv">$ </span>faker profile ssn,birthdate
</span><span class='line'><span class="o">{</span><span class="s1">&#39;ssn&#39;</span>: u<span class="s1">&#39;628-10-1085&#39;</span>, <span class="s1">&#39;birthdate&#39;</span>: <span class="s1">&#39;2008-03-29&#39;</span><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="nv">$ </span>faker -r<span class="o">=</span><span class="m">3</span> -s<span class="o">=</span><span class="s2">&quot;;&quot;</span> name
</span><span class='line'>Willam Kertzmann<span class="p">;</span>
</span><span class='line'>Josiah Maggio<span class="p">;</span>
</span><span class='line'>Gayla Schmitt<span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">$ </span>faker -h
</span><span class='line'>usage: faker <span class="o">[</span>-h<span class="o">]</span> <span class="o">[</span>--version<span class="o">]</span> <span class="o">[</span>-o output<span class="o">]</span> <span class="o">[</span>-l LOCALE<span class="o">]</span> <span class="o">[</span>-r REPEAT<span class="o">]</span> <span class="o">[</span>-s SEP<span class="o">]</span>
</span><span class='line'>             <span class="o">[</span>-i <span class="o">[</span>INCLUDE <span class="o">[</span>INCLUDE ...<span class="o">]]]</span>
</span><span class='line'>             <span class="o">[</span>fake<span class="o">]</span> <span class="o">[</span>fake argument <span class="o">[</span>fake argument ...<span class="o">]]</span>
</span><span class='line'>...
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python调试终端]]></title>
    <link href="http://blog.fasionchan.com/blog/2016/12/09/python-diao-shi-zhong-duan/"/>
    <updated>2016-12-09T18:58:43+08:00</updated>
    <id>http://blog.fasionchan.com/blog/2016/12/09/python-diao-shi-zhong-duan</id>
    <content type="html"><![CDATA[<p>后端服务程序开发运营过程中，难免会遇到一些BUG疑难杂症，是日志输出等调试手段无法定位的。
如有有一个工具，可以连上服务程序，查询服务中间状态或者修改程序变量，势必加速问题定位及解决。</p>

<p>本模块就是您想要的工具~</p>

<!--more-->


<h1>安装</h1>

<p>模块代码已经在<code>github</code>上开源：<a href="https://github.com/fasionchan/libase/blob/master/libase/server/console.py">libase.server.console</a>，可以直接把代码<code>clone</code>下来安装。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git clone https://github.com/fasionchan/libase.git
</span><span class='line'>$ cd libase
</span><span class='line'>$ python setup.py install</span></code></pre></td></tr></table></div></figure>


<p>当然了，<code>libase</code>也已经发布到<a href="https://pypi.python.org/pypi">PyPI</a>上了。因此，更方便的安装方式是使用<code>pip</code>：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pip install libase</span></code></pre></td></tr></table></div></figure>


<h1>服务接入</h1>

<p>需要远程调试的程序可以用<code>start_console_server</code>快捷启动一个远程调试终端服务。
然后，使用<code>pyconsole</code>命令便可以连上该程序，并初始化一个<code>Python</code>控制台用于调试了。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import time
</span><span class='line'>
</span><span class='line'>from libase.server.console import start_console_server
</span><span class='line'>
</span><span class='line'>counter = 0
</span><span class='line'>
</span><span class='line'>start_console_server()
</span><span class='line'>
</span><span class='line'>while True:
</span><span class='line'>    print counter
</span><span class='line'>    counter += 1
</span><span class='line'>    time.sleep(1)</span></code></pre></td></tr></table></div></figure>


<p>例子是一个计算程序，使用<code>start_console_server</code>接入远程调试终端服务，端口为默认值<code>4444</code>。</p>

<h3>连接调试</h3>

<p><code>libase</code>提供一个用于连接远程调试终端的程序<code>pyconsole</code>，以访问上述程序为例：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'>$ pyconsole 4444
</span><span class='line'>Python 2.7.3 (default, Jan  2 2013, 13:56:14)
</span><span class='line'>[GCC 4.7.2] on linux2
</span><span class='line'>Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
</span><span class='line'>(ConsoleProxy)
</span><span class='line'>&gt;&gt;&gt; print main.counter
</span><span class='line'>93
</span><span class='line'>&gt;&gt;&gt; main.counter = 0
</span><span class='line'>&gt;&gt;&gt; print main.counter
</span><span class='line'>1
</span><span class='line'>&gt;&gt;&gt; print main.counter
</span><span class='line'>2
</span></code></pre></td></tr></table></div></figure>


<p>注意到，默认已经将进程的<code>__main__</code>模块引入到当前名字空间，名为<code>main</code>，其效果等同于在<code>pyconsole</code>中执行<code>import __main__ as main</code>。</p>

<h1>高级用法</h1>

<h2>接口文档</h2>

<h3>start_console_server</h3>

<p><strong>start_console_server(port=4444, addr=&lsquo;localhost&rsquo;, &lsquo;code&rsquo;=&lsquo;&rsquo;)</strong></p>

<p>接入远程调试终端服务，返回一个<code>ConsoleServer</code>对象。</p>

<ul>
<li>port 远程调试终端服务监听的端口，默认为<code>4444</code></li>
<li>addr 远程调试终端服务监听的地址，可以为<code>IP</code>或者机器名，默认为<code>localhost</code></li>
<li>code 初始化代码，可用于预先引入一些对象到终端所在名字空间</li>
</ul>


<h3>run_console_proxy</h3>

<p><strong>run_console_proxy(port=4444, addr=&lsquo;localhost&rsquo;)</strong></p>

<p>以给定地址端口信息，连上接入远程调试终端的服务，并启动一个<code>Python</code>控制台。</p>

<ul>
<li>port 远程调试终端所在端口，默认为<code>4444</code></li>
<li>addr 远程调试中断所在机器地址，可以是<code>IP</code>或者机器名，默认为<code>localhost</code></li>
</ul>


<h2>工具命令</h2>

<h3>pyconsole</h3>

<p>用法：pyconsole [port] [addr]</p>

<ul>
<li>port 远程调试终端所在端口，默认为<code>4444</code></li>
<li>addr 远程调试中断所在机器地址，可以是<code>IP</code>或者机器名，默认为<code>localhost</code></li>
</ul>


<p>该命令，只是把<code>run_console_proxy</code>命令化，实现如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'>import sys
</span><span class='line'>import rlcompleter
</span><span class='line'>
</span><span class='line'>from libase.server.console import run_console_proxy
</span><span class='line'>
</span><span class='line'>if __name__ == &#39;__main__&#39;:
</span><span class='line'>    run_console_proxy(*sys.argv[1:])
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mac下Ruby安装小结]]></title>
    <link href="http://blog.fasionchan.com/blog/2016/12/08/mac-xia-ruby-an-zhuang-xiao-jie/"/>
    <updated>2016-12-08T22:29:43+08:00</updated>
    <id>http://blog.fasionchan.com/blog/2016/12/08/mac-xia-ruby-an-zhuang-xiao-jie</id>
    <content type="html"><![CDATA[<p>最近，重新拿起博客，发现已有一年多没有动过的<code>Octopress</code>跑不起来了，囧。并不意外，每次<code>Mac</code>一升级，总有一些东西会挂掉，久而久之习惯了。</p>

<p>如何让<code>Octopress</code>重新跑起来呢？重新看安装文档，大头只是安装一个<code>ruby</code>而已。但是，由于对<code>ruby</code>并不熟悉，中间还是踩了个大坑。因此，有必要记一下，免得以后再犯。</p>

<!--more-->


<h1>安装rbenv</h1>

<p><code>rbenv</code>是什么鬼？</p>

<p>我们知道，系统本来已经有一个<code>ruby</code>了，不信命令行运行<code>which ruby</code>看看。这个是系统自带的，一般版本都是极其老的。然而，我们在用一些软件环境时，却是需要某个特定版本<code>ruby</code>的。这时，你可以选择重新编译一个，然后进行安装。问题是，安装到系统这个动作太暴力了，影响范围略大，可能会搞挂其他东西。如果可以安装多个版本的<code>ruby</code>，与系统独立，按需使用，那敢情好。<code>rbenv</code>就是这样的工具~</p>

<p>好吧，那么要怎么安装呢？<code>Mac</code>下，一般用<code>brew</code>安装软件，<code>rbenv</code>也不例外：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>brew update
</span><span class='line'>brew install rbenv
</span><span class='line'>brew install ruby-build</span></code></pre></td></tr></table></div></figure>


<h1>安装ruby</h1>

<p><code>rbenv</code>完成安装后，<code>ruby</code>的安装就没有任何难度了：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rbenv install 1.9.3-p0
</span><span class='line'>rbenv local 1.9.3-p0
</span><span class='line'>rbenv rehash</span></code></pre></td></tr></table></div></figure>


<p>好吧，这么说来，写这篇文章有什么意义呢？别急，下面不是还有<strong>坑</strong>一节嘛~</p>

<h1>坑</h1>

<p>上面的安装步骤正确操作完，我发现<code>ruby</code>缺不是用<code>rbenv local</code>选定的版本！我运行<code>which ruby</code>看到还是用系统的，什么鬼！</p>

<p>确定<code>rbenv</code>没生效，但暂时不知道为什么。我猜<code>rbenv</code>应该是通过<code>PATH</code>环境变量生效的，但是看了一下并没有什么变化。<code>rbenv help</code>也看不到任何关于生效的内容，无奈只能<code>Google</code>了。</p>

<p><code>F*ck!</code>确实需要做点什么才能生效，<code>rbenv init</code>就是需要做的内容，但是<code>rbenv help</code>一个字也没提？</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ rbenv init
</span><span class='line'># Load rbenv automatically by appending
</span><span class='line'># the following to ~/.bashrc:
</span><span class='line'>
</span><span class='line'>eval "$(rbenv init -)"
</span></code></pre></td></tr></table></div></figure>


<p><code>shell</code>下运行<code>eval "$(rbenv init -)"</code>后，再运行<code>which ruby</code>就看到确实生效了！这个操作最好根据指引放到<code>.bashrc</code>里，这样就不要要每次都要运行一遍。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用gdb调试Python程序]]></title>
    <link href="http://blog.fasionchan.com/blog/2016/12/07/shi-yong-gdb-tiao-shi-python-cheng-xu/"/>
    <updated>2016-12-07T22:51:29+08:00</updated>
    <id>http://blog.fasionchan.com/blog/2016/12/07/shi-yong-gdb-tiao-shi-python-cheng-xu</id>
    <content type="html"><![CDATA[<p>最近在为一个监控系统开发<code>agent</code>，需要支持<code>Linux</code>、<code>FreeBSD</code>及<code>Windows</code>等操作系统。复杂的线上环境，带来了一系列诡异的问题，尽管代码上线前在为数不少的测试机器验证过。</p>

<p><code>Python</code>程序吐<code>coredump</code>文件怎么办？很多人都会想到<code>gdb</code>加载<code>coredump</code>文件，然后查看信号及堆栈信息，以此分析原因。堆栈信息在调试中非常有用，但是别忘了，你写的是<code>Python</code>代码，但是<code>gdb</code>给你的是<code>C</code>堆栈信息！似乎没啥鸟用！难道要撸<code>Python</code>源码然后分析各种核心数据结构吗？有什么方式可以查看到<code>Python</code>堆栈信息吗？</p>

<p>还遇到过另一个问题，一个<code>Python</code>进程突然间陷入死循环，所有其他线程都调度不到。遇到这种情况，首先可能需要知道死循环到底在干什么。如何获悉呢？可能用<code>strace</code>跟一下系统调用可以看出一点端倪。但是一个堆栈信息更为具体更有说服力，就算是只有<code>C</code>堆栈信息有时也是足以说明问题的。</p>

<p><code>gdb</code>就可以解决以上难题(其实远不止)，接下来，我们一起看看具体要怎么操作吧~</p>

<!--more-->


<h1>准备</h1>

<p>首先得有<code>gdb</code>吧，这个就不细说了，<code>debian</code>系发行版上运行以下命令完成安装：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>apt-get install gdb</span></code></pre></td></tr></table></div></figure>


<p>其次，还需要装一个包——<code>python-dbg</code>。这个包有什么作用呢？前面不是抱怨过<code>C</code>堆栈对于调试一个<code>Python</code>有何用？我们更需要的是<code>Python</code>堆栈信息，<code>python-dbg</code>就是为了完成这个使命。</p>

<h1>运行</h1>

<p>全新启动一个<code>Python</code>程序并进行调试，可以采用交互式方式，先启动<code>gdb</code>然后在<code>gdb shell</code>中启动<code>Python</code>程序：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ gdb python
</span><span class='line'>...
</span><span class='line'>(gdb) run &lt;programname&gt;.py &lt;arguments&gt;</span></code></pre></td></tr></table></div></figure>


<p>当然了，也可以一步到位，一条命令搞定这两步：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>gdb -ex r --args python &lt;programname&gt;.py &lt;arguments&gt;</span></code></pre></td></tr></table></div></figure>


<p>遗憾的是，现实中往往是这样的情景——一个正在运行的程序突然异常了，你需要调试它！这时为之奈何？</p>

<p>有一种方法你可以给它发一个信号，出一个<code>coredump</code>文件，然后用<code>gdb</code>来调试<code>coredump</code>文件：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>gdb &lt;coredump_file&gt;</span></code></pre></td></tr></table></div></figure>


<p>显然易见，这并不是一种很好的方式，那么有没有什么办法可以捕获进程并调试呢？你想得到的很有可能都有人实现了——</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>gdb python &lt;process id&gt;</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>gdb attach &lt;process id&gt;</span></code></pre></td></tr></table></div></figure>


<p>这两种方式都可以让<code>gdb</code>捕获一个进程。因此，我们需要做的只是确定问题进程的<code>pid</code>，这个总该没有难度了吧——<code>top</code>、<code>ps</code>等等一系列命令都可以做到。</p>

<h1>堆栈查看</h1>

<p>查看<code>C</code>堆栈信息，用过<code>gdb</code>命令的估计都知道怎么做：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(gdb) bt
</span><span class='line'>#0 0x0000002a95b3b705 in raise () from /lib/libc.so.6
</span><span class='line'>#1 0x0000002a95b3ce8e in abort () from /lib/libc.so.6
</span><span class='line'>#2 0x00000000004c164f in posix_abort (self=0x0, noargs=0x0) at ../Modules/posixmodule.c:7158
</span><span class='line'>#3 0x0000000000489fac in call_function (pp_stack=0x7fbffff110, oparg=0) at ../Python/ceval.c:3531
</span><span class='line'>#4 0x0000000000485fc2 in PyEval_EvalFrame (f=0x66ccd8) at ../Python/ceval.c:2163
</span><span class='line'>...</span></code></pre></td></tr></table></div></figure>


<p>那么，怎么查看<code>Python</code>堆栈呢。安装<code>python-gdb</code>之后，<code>gdb</code>会提供若干相关的操作。其中<code>py-bt</code>就是用来查看<code>Python</code>堆栈的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(gdb) py-bt</span></code></pre></td></tr></table></div></figure>


<h1>线程查看</h1>

<p>调试多线程程序，首先总得搞清楚到底有哪些线程吧：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(gdb) info threads
</span><span class='line'> Id Target Id Frame
</span><span class='line'>  37 Thread 0xa29feb40 (LWP 17914) "NotificationThr" 0xb7fdd424 in __kernel_vsyscall ()
</span><span class='line'>  36 Thread 0xa03fcb40 (LWP 17913) "python2.7" 0xb7fdd424 in __kernel_vsyscall ()
</span><span class='line'>  35 Thread 0xa0bfdb40 (LWP 17911) "QProcessManager" 0xb7fdd424 in __kernel_vsyscall ()
</span><span class='line'>  34 Thread 0xa13feb40 (LWP 17910) "python2.7" 0xb7fdd424 in __kernel_vsyscall ()
</span><span class='line'>  33 Thread 0xa1bffb40 (LWP 17909) "python2.7" 0xb7fdd424 in __kernel_vsyscall ()
</span><span class='line'>  31 Thread 0xa31ffb40 (LWP 17907) "QFileInfoGather" 0xb7fdd424 in __kernel_vsyscall ()
</span><span class='line'>  30 Thread 0xa3fdfb40 (LWP 17906) "QInotifyFileSys" 0xb7fdd424 in __kernel_vsyscall ()
</span><span class='line'>  29 Thread 0xa481cb40 (LWP 17905) "QFileInfoGather" 0xb7fdd424 in __kernel_vsyscall ()
</span><span class='line'>  7  Thread 0xa508db40 (LWP 17883) "QThread" 0xb7fdd424 in __kernel_vsyscall ()
</span><span class='line'>  6  Thread 0xa5cebb40 (LWP 17882) "python2.7" 0xb7fdd424 in __kernel_vsyscall ()
</span><span class='line'>  5  Thread 0xa660cb40 (LWP 17881) "python2.7" 0xb7fdd424 in __kernel_vsyscall ()
</span><span class='line'>  3  Thread 0xabdffb40 (LWP 17876) "gdbus" 0xb7fdd424 in __kernel_vsyscall ()
</span><span class='line'>  2  Thread 0xac7b7b40 (LWP 17875) "dconf worker" 0xb7fdd424 in __kernel_vsyscall ()
</span><span class='line'>* 1  Thread 0xb7d876c0 (LWP 17863) "python2.7" 0xb7fdd424 in __kernel_vsyscall ()</span></code></pre></td></tr></table></div></figure>


<p>请注意<code>*</code>号哦——它标识的是当前线程。</p>

<p>那么如何切换线程呢？</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(gdb) thread 37</span></code></pre></td></tr></table></div></figure>


<p>这样就将37号线程设置为当前线程进行调试了。</p>

<p>好，那么怎么查看当前线程的相关信息呢？上节中，<code>py-bt</code>可以帮上忙——至少知道线程的执行堆栈。还有一个操作<code>py-list</code>，可以清楚看到当前执行到代码的第几行，还有前后若干行的代码可以对照哦：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(gdb) py-list
</span><span class='line'>2025         # Open external files with our Mac app
</span><span class='line'>2026         if sys.platform == "darwin" and 'Spyder.app' in __file__:
</span><span class='line'>2027             main.connect(app, SIGNAL('open_external_file(QString)'),
</span><span class='line'>2028                          lambda fname: main.open_external_file(fname))
</span><span class='line'>2029
</span><span class='line'>&gt;2030        app.exec_()
</span><span class='line'>2031         return main
</span><span class='line'>2032
</span><span class='line'>2033
</span><span class='line'>2034     def __remove_temp_session():
</span><span class='line'>2035         if osp.isfile(TEMP_SESSION_PATH):</span></code></pre></td></tr></table></div></figure>


<p>还有更6的，查看所有进程执行位置，非常方便有木有：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(gdb) thread apply all py-list
</span><span class='line'>...
</span><span class='line'> 200
</span><span class='line'> 201         def accept(self):
</span><span class='line'>&gt;202             sock, addr = self._sock.accept()
</span><span class='line'> 203             return _socketobject(_sock=sock), addr
</span><span class='line'> 204         accept.__doc__ = _realsocket.accept.__doc__
</span><span class='line'> 205
</span><span class='line'> 206         def dup(self):
</span><span class='line'> 207             """dup() -&gt; socket object
</span><span class='line'>
</span><span class='line'>Thread 35 (Thread 0xa0bfdb40 (LWP 17911)):
</span><span class='line'>Unable to locate python frame
</span><span class='line'>
</span><span class='line'>Thread 34 (Thread 0xa13feb40 (LWP 17910)):
</span><span class='line'> 197             for method in _delegate_methods:
</span><span class='line'> 198                 setattr(self, method, dummy)
</span><span class='line'> 199         close.__doc__ = _realsocket.close.__doc__
</span><span class='line'> 200
</span><span class='line'> 201         def accept(self):
</span><span class='line'>&gt;202             sock, addr = self._sock.accept()
</span><span class='line'> 203             return _socketobject(_sock=sock), addr...</span></code></pre></td></tr></table></div></figure>


<h1>参考资料</h1>

<p><a href="https://wiki.python.org/moin/DebuggingWithGdb">https://wiki.python.org/moin/DebuggingWithGdb</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[译文]深入理解Linux TCP Backlog]]></title>
    <link href="http://blog.fasionchan.com/blog/2016/11/07/yi-wen-shen-ru-li-jie-linux-tcp-backlog/"/>
    <updated>2016-11-07T21:57:09+08:00</updated>
    <id>http://blog.fasionchan.com/blog/2016/11/07/yi-wen-shen-ru-li-jie-linux-tcp-backlog</id>
    <content type="html"><![CDATA[<p>当应用程序调用<code>listen</code>系统调用让一个<code>socket</code>进入<code>LISTEN</code>状态时，需要指定一个参数<code>backlog</code>。这个<code>backlog</code>参数经常被描述为，新连接队列的长度限制。</p>

<p><img src="http://upload-images.jianshu.io/upload_images/2740477-d1ebcbbc58e3b9f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="tcp-state-diagram.png" /></p>

<!--more-->


<p>由于<code>TCP</code>建立连接使用3次握手，因此，一个新连接在到达<code>ESTABLISHED</code>状态可以被<code>accept</code>系统调用返回给应用程序前，必须经过一个中间状态<code>SYN RECEIVED</code>(见上图)。这意味着，<code>TCP/IP</code>协议栈在实现<code>backlog</code>队列时，有两种不同的选择：</p>

<ol>
<li><p>仅使用一个队列，队列规模由<code>listen</code>系统调用<code>backlog</code>参数指定。当协议栈收到一个<code>SYN</code>包时，响应<code>SYN/ACK</code>包并且将连接加进该队列。当相应的<code>ACK</code>响应包收到后，连接变为<code>ESTABLISHED</code>状态，可以向应用程序返回。这意味着队列里的连接可以有两种不同的状态：<code>SEND RECEIVED</code>和<code>ESTABLISHED</code>。只有后一种连接才能被<code>accept</code>系统调用返回给应用程序。</p></li>
<li><p>使用两个队列——<code>SYN</code>队列(待完成连接队列)和<code>accept</code>队列(已完成连接队列)。状态为<code>SYN RECEIVED</code>的连接进入<code>SYN</code>队列，后续当状态变更为<code>ESTABLISHED</code>时移到<code>accept</code>队列(即收到3次握手中最后一个<code>ACK</code>包)。顾名思义，<code>accept</code>系统调用就只是简单地从<code>accept</code>队列消费新连接。在这种情况下，<code>listen</code>系统调用<code>backlog</code>参数决定<code>accept</code>队列的最大规模。</p></li>
</ol>


<p>历史上，起源于<code>BSD</code>的<code>TCP</code>实现使用第一种方法。这个方案意味着，但<code>backlog</code>限制达到，系统将停止对<code>SYN</code>包响应<code>SYN/ACK</code>包。通常，协议栈只是丢弃<code>SYN</code>包(而不是回一个<code>RST</code>包)以便客户端可以重试(而不是异常退出)。</p>

<p><code>TCP/IP详解 卷3</code>第<code>14.5</code>节中有提到这一点。书中作者提到，<code>BSD</code>实现虽然使用了两个独立的队列，但是行为跟使用一个队列并没什么区别。</p>

<p>在<code>Linux</code>上，情况有所不同，情况<code>listen</code>系统调用<code>man</code>文档页：</p>

<blockquote><p>The  behavior  of  the  backlog  argument on TCP sockets changed with Linux 2.2.  Now it specifies the queue length for completely established sockets waiting to be accepted, instead of the number of incomplete connection requests.  The maximum length of the queue for incomplete sockets can be set using /proc/sys/net/ipv4/tcp_max_syn_backlog.  When syncookies are enabled there is no logical maximum length and this setting is ignored.</p>

<p>意思是，<code>backlog</code>参数的行为在<code>Linux</code>2.2之后有所改变。现在，它指定了等待<code>accept</code>系统调用的已建立连接队列的长度，而不是待完成连接请求数。待完成连接队列长度由<code>/proc/sys/net/ipv4/tcp_max_syn_backlog</code>指定；在<code>syncookies</code>启用的情况下，逻辑上没有最大值限制，这个设置便被忽略。</p></blockquote>

<p>也就是说，当前版本的<code>Linux</code>实现了第二种方案，使用两个队列——一个<code>SYN</code>队列，长度系统级别可设置以及一个<code>accept</code>队列长度由应用程序指定。</p>

<p>现在，一个需要考虑的问题是在<code>accept</code>队列已满而一个已完成新连接需要用<code>SYN</code>队列移动到<code>accept</code>队列(收到3次握手中最后一个<code>ACK</code>包)，这个实现方案是什么行为。这种情况下，由<code>net/ipv4/tcp_minisocks.c</code>中<code>tcp_check_req</code>函数处理：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>child = inet_csk(sk)-&gt;icsk_af_ops-&gt;syn_recv_sock(sk, skb, req, NULL);
</span><span class='line'>if (child == NULL)
</span><span class='line'>    goto listen_overflow;</span></code></pre></td></tr></table></div></figure>


<p>对于<code>IPv4</code>，第一行代码实际上调用的是<code>net/ipv4/tcp_ipv4.c</code>中的<code>tcp_v4_syn_recv_sock</code>函数，代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (sk_acceptq_is_full(sk))
</span><span class='line'>    goto exit_overflow;</span></code></pre></td></tr></table></div></figure>


<p>可以看到，这里会检查<code>accept</code>队列的长度。如果队列已满，跳到<code>exit_overflow</code>标签执行一些清理工作、更新<code>/proc/net/netstat</code>中的统计项<code>ListenOverflows</code>和<code>ListenDrops</code>，最后返回<code>NULL</code>。这会触发<code>tcp_check_req</code>函数跳到<code>listen_overflow</code>标签执行代码。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>listen_overflow:
</span><span class='line'>    if (!sysctl_tcp_abort_on_overflow) {
</span><span class='line'>        inet_rsk(req)-&gt;acked = 1;
</span><span class='line'>        return NULL;
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<p>很显然，除非<code>/proc/sys/net/ipv4/tcp_abort_on_overflow</code>被设置为<code>1</code>(这种情况下发送一个<code>RST</code>包)，实现什么都没做。</p>

<p>总结一下：<code>Linux</code>内核协议栈在收到3次握手最后一个<code>ACK</code>包，确认一个新连接已完成，而<code>accept</code>队列已满的情况下，会忽略这个包。一开始您可能会对此感到奇怪——别忘了<code>SYN RECEIVED</code>状态下有一个计时器实现：如果<code>ACK</code>包没有收到(或者是我们讨论的忽略)，协议栈会重发<code>SYN/ACK</code>包(重试次数由<code>/proc/sys/net/ipv4/tcp_synack_retries</code>决定)。</p>

<p>看以下抓包结果就非常明显——一个客户正尝试连接一个已经达到其最大<code>backlog</code>的<code>socket</code>：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  0.000  127.0.0.1 -&gt; 127.0.0.1  TCP 74 53302 &gt; 9999 [SYN] Seq=0 Len=0
</span><span class='line'>  0.000  127.0.0.1 -&gt; 127.0.0.1  TCP 74 9999 &gt; 53302 [SYN, ACK] Seq=0 Ack=1 Len=0
</span><span class='line'>  0.000  127.0.0.1 -&gt; 127.0.0.1  TCP 66 53302 &gt; 9999 [ACK] Seq=1 Ack=1 Len=0
</span><span class='line'>  0.000  127.0.0.1 -&gt; 127.0.0.1  TCP 71 53302 &gt; 9999 [PSH, ACK] Seq=1 Ack=1 Len=5
</span><span class='line'>  0.207  127.0.0.1 -&gt; 127.0.0.1  TCP 71 [TCP Retransmission] 53302 &gt; 9999 [PSH, ACK] Seq=1 Ack=1 Len=5
</span><span class='line'>  0.623  127.0.0.1 -&gt; 127.0.0.1  TCP 71 [TCP Retransmission] 53302 &gt; 9999 [PSH, ACK] Seq=1 Ack=1 Len=5
</span><span class='line'>  1.199  127.0.0.1 -&gt; 127.0.0.1  TCP 74 9999 &gt; 53302 [SYN, ACK] Seq=0 Ack=1 Len=0
</span><span class='line'>  1.199  127.0.0.1 -&gt; 127.0.0.1  TCP 66 [TCP Dup ACK 6#1] 53302 &gt; 9999 [ACK] Seq=6 Ack=1 Len=0
</span><span class='line'>  1.455  127.0.0.1 -&gt; 127.0.0.1  TCP 71 [TCP Retransmission] 53302 &gt; 9999 [PSH, ACK] Seq=1 Ack=1 Len=5
</span><span class='line'>  3.123  127.0.0.1 -&gt; 127.0.0.1  TCP 71 [TCP Retransmission] 53302 &gt; 9999 [PSH, ACK] Seq=1 Ack=1 Len=5
</span><span class='line'>  3.399  127.0.0.1 -&gt; 127.0.0.1  TCP 74 9999 &gt; 53302 [SYN, ACK] Seq=0 Ack=1 Len=0
</span><span class='line'>  3.399  127.0.0.1 -&gt; 127.0.0.1  TCP 66 [TCP Dup ACK 10#1] 53302 &gt; 9999 [ACK] Seq=6 Ack=1 Len=0
</span><span class='line'>  6.459  127.0.0.1 -&gt; 127.0.0.1  TCP 71 [TCP Retransmission] 53302 &gt; 9999 [PSH, ACK] Seq=1 Ack=1 Len=5
</span><span class='line'>  7.599  127.0.0.1 -&gt; 127.0.0.1  TCP 74 9999 &gt; 53302 [SYN, ACK] Seq=0 Ack=1 Len=0
</span><span class='line'>  7.599  127.0.0.1 -&gt; 127.0.0.1  TCP 66 [TCP Dup ACK 13#1] 53302 &gt; 9999 [ACK] Seq=6 Ack=1 Len=0
</span><span class='line'> 13.131  127.0.0.1 -&gt; 127.0.0.1  TCP 71 [TCP Retransmission] 53302 &gt; 9999 [PSH, ACK] Seq=1 Ack=1 Len=5
</span><span class='line'> 15.599  127.0.0.1 -&gt; 127.0.0.1  TCP 74 9999 &gt; 53302 [SYN, ACK] Seq=0 Ack=1 Len=0
</span><span class='line'> 15.599  127.0.0.1 -&gt; 127.0.0.1  TCP 66 [TCP Dup ACK 16#1] 53302 &gt; 9999 [ACK] Seq=6 Ack=1 Len=0
</span><span class='line'> 26.491  127.0.0.1 -&gt; 127.0.0.1  TCP 71 [TCP Retransmission] 53302 &gt; 9999 [PSH, ACK] Seq=1 Ack=1 Len=5
</span><span class='line'> 31.599  127.0.0.1 -&gt; 127.0.0.1  TCP 74 9999 &gt; 53302 [SYN, ACK] Seq=0 Ack=1 Len=0
</span><span class='line'> 31.599  127.0.0.1 -&gt; 127.0.0.1  TCP 66 [TCP Dup ACK 19#1] 53302 &gt; 9999 [ACK] Seq=6 Ack=1 Len=0
</span><span class='line'> 53.179  127.0.0.1 -&gt; 127.0.0.1  TCP 71 [TCP Retransmission] 53302 &gt; 9999 [PSH, ACK] Seq=1 Ack=1 Len=5
</span><span class='line'>106.491  127.0.0.1 -&gt; 127.0.0.1  TCP 71 [TCP Retransmission] 53302 &gt; 9999 [PSH, ACK] Seq=1 Ack=1 Len=5
</span><span class='line'>106.491  127.0.0.1 -&gt; 127.0.0.1  TCP 54 9999 &gt; 53302 [RST] Seq=1 Len=0</span></code></pre></td></tr></table></div></figure>


<p>由于客户端的<code>TCP</code>实现在收到多个<code>SYN/ACK</code>包时，认为<code>ACK</code>包已经丢失了并且重传它。如果在<code>SYN/ACK</code>重试次数达到限制前，服务端应用从<code>accept</code>队列接收连接，使得<code>backlog</code>减少，那么协议栈会处理这些重传的<code>ACK</code>包，将连接状态从<code>SYN RECEIVED</code>变更到<code>ESTABLISHED</code>并且将其加入<code>accept</code>队列。否则，正如以上包跟踪所示，客户读会收到一个<code>RST</code>包宣告连接失败。</p>

<p>在客户端看来，第一次收到<code>SYN/ACK</code>包之后，连接就会进入<code>ESTABLISHED</code>状态。如果这时客户端首先开始发送数据，那么数据也会被重传。好在<code>TCP</code>有慢启动机制，在服务端还没进入<code>ESTABLISHED</code>之前，客户端能发送的数据非常有限。</p>

<p>相反，如果客户端一开始就在等待服务端，而服务端<code>backlog</code>没能减少，那么最后的结果是连接在客户端看来是<code>ESTABLISHED</code>状态，但在服务端看来是<code>CLOSED</code>状态。这也就是所谓的半开连接。</p>

<p>有一点还没讨论的是：<code>man listen</code>中提到每次收到新<code>SYN</code>包，内核往<code>SYN</code>队列追加一个新连接(除非该队列已满)。事实并非如此，<code>net/ipv4/tcp_ipv4.c</code>中<code>tcp_v4_conn_request</code>函数负责处理<code>SYN</code>包，请看以下代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (sk_acceptq_is_full(sk) && inet_csk_reqsk_queue_young(sk) &gt; 1) {
</span><span class='line'>    NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);
</span><span class='line'>    goto drop;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>可以看到，在<code>accept</code>队列已满的情况下，内核会强制限制<code>SYN</code>包的接收速率。如果有大量<code>SYN</code>包待处理，它们其中的一些会被丢弃。这样看来，就完全依靠客户端重传<code>SYN</code>包了，这种行为跟<code>BSD</code>实现一样。</p>

<p>下结论前，需要再研究以下<code>Linux</code>这种实现方式跟<code>BSD</code>相比有什么优势。<code>Stevens</code>是这样说的：</p>

<blockquote><p>在<code>accept</code>队列已满或者<code>SYN</code>队列已满的情况下，<code>backlog</code>会达到限制。第一种情况经常发生在服务器或者服务器进程非常繁忙的情况下，进程没法足够快地调用<code>accept</code>系统调用从中取出已完成连接。后者是<code>HTTP</code>服务器经常面临的问题，在服务端客户端往返时间非常长的时候(相对于连接到达速率)，因为新<code>SYN</code>包在往返时间内都会占据一个连接对象。</p>

<p>大多数情况下<code>accept</code>队列都是空的，因为一旦有一个新连接进入队列，阻塞等待的<code>accept</code>系统调用将返回，然后连接从队列中取出。</p></blockquote>

<p><code>Stevens</code>建议的解决方案是简单地调大<code>backlog</code>。但有个问题是，应用程序在调优<code>backlog</code>参数时，不仅需要考虑自身对新连接的处理逻辑，还需要考虑网络状况，包括往返时间等。Linux实现实际上分成两部分：应用程序只负责调解<code>backlog</code>参数，确保<code>accept</code>调用足够快以免<code>accept</code>队列被塞满；系统管理员则根据网络状况调节<code>/proc/sys/net/ipv4/tcp_max_syn_backlog</code>，各司其职。</p>

<p>本文译自：<a href="http://veithen.github.io/2014/01/01/how-tcp-backlog-works-in-linux.html">How TCP backlog works in Linux</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自己发布Python包]]></title>
    <link href="http://blog.fasionchan.com/blog/2016/10/23/zi-ji-fa-bu-python-bao/"/>
    <updated>2016-10-23T18:50:04+08:00</updated>
    <id>http://blog.fasionchan.com/blog/2016/10/23/zi-ji-fa-bu-python-bao</id>
    <content type="html"><![CDATA[<h1>注册</h1>

<p>先在<code>Python</code>官网注册一个账号，地址是：<a href="https://pypi.python.org/pypi">https://pypi.python.org/pypi</a>。</p>

<!--more-->


<h1>配置</h1>

<p>账号注册后，就可以用其来登记新建的<code>Python</code>包，以及上传包更新。上传新包一般由<code>twine</code>命令完成，<code>twine</code>需要知道<code>Python</code>仓库地址以及账号信息。因此，可以将这些信息写在配置文件<code>~/.pypirc</code>里，这样运行命令时便不需要再次输入了。配置如何写呢？以<code>foo</code>为用户名，<code>bar</code>为密码为例：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[distutils]
</span><span class='line'>index-servers=pypi
</span><span class='line'>
</span><span class='line'>[pypi]
</span><span class='line'>repository = https://pypi.python.org/pypi
</span><span class='line'>username = foo
</span><span class='line'>password = bar</span></code></pre></td></tr></table></div></figure>


<p>其中，密码也可以不写进配置，这样每次运行<code>twine</code>时，将提示输入密码。</p>

<h1>准备</h1>

<p>编写<code>Python</code>包的过程，这里就不细说了。本文的重点是怎么将自己的<code>Python</code>包发布出去，然后可以用<code>pip</code>命令安装。</p>

<p><code>Python</code>包的实现方式可以参考。其实无非就是规划好目录结构，然后编写<code>setup.py</code>文件：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#!/usr/bin/env python
</span><span class='line'># -*- encoding=utf8 -*-
</span><span class='line'>
</span><span class='line'>'''
</span><span class='line'>FileName:   setup.py
</span><span class='line'>Author:     Fasion Chan
</span><span class='line'>@contact:   fasionchan@gmail.com
</span><span class='line'>@version:   $Id$
</span><span class='line'>
</span><span class='line'>Description:
</span><span class='line'>
</span><span class='line'>Changelog:
</span><span class='line'>
</span><span class='line'>'''
</span><span class='line'>
</span><span class='line'>VERSION = '1.0'
</span><span class='line'>
</span><span class='line'>from setuptools import (
</span><span class='line'>    setup,
</span><span class='line'>    )
</span><span class='line'>
</span><span class='line'>setup(
</span><span class='line'>    name='libase',
</span><span class='line'>    version=VERSION,
</span><span class='line'>    author='Fasion Chan',
</span><span class='line'>    author_email='fasionchan@gmail.com',
</span><span class='line'>    packages=[
</span><span class='line'>        'libase',
</span><span class='line'>        ],
</span><span class='line'>    scripts=[
</span><span class='line'>        ],
</span><span class='line'>    package_data={
</span><span class='line'>        },
</span><span class='line'>    install_requires=[
</span><span class='line'>        ],
</span><span class='line'>    )</span></code></pre></td></tr></table></div></figure>


<h1>登记</h1>

<p>运行命令<code>python setup.py egg_info</code>生成包信息，找到<code>xxxx.egg_info</code>目录下<code>PKG-INFO</code>文件，在<code>Python</code>官网<a href="https://pypi.python.org/pypi?%3Aaction=submit_form">提交表单</a>上传即可。</p>

<h1>构建</h1>

<p>运行命令<code>python setup.py sdist</code>进行构建并打包。完成之后，在<code>dist</code>目录下可以看到形如<code>xxxx-1.0.tar.gz</code>的压缩包。</p>

<h1>上传</h1>

<p>运行命令<code>twine upload dist/*</code>便可将构建的所有包上传，这时便大功告成了！</p>

<h1>应用</h1>

<p>运行命令<code>pip install xxxx</code>便可以安装你发布的<code>Python</code>包了！你可以发布任何你想发布的东西，任何人也可以安装任何你发布的东西，成就感杠杠的有木有！</p>

<p>我们提倡自由分享的精神，有用的代码无私奉献出来可以节约很多人很多时间！<code>Life is short, use Python!</code></p>

<p>当然了，努力提升自己，分享高质量代码，不要坑别人哦~</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux文件描述符]]></title>
    <link href="http://blog.fasionchan.com/blog/2016/09/20/linux-wen-jian-miao-shu-fu/"/>
    <updated>2016-09-20T22:16:26+08:00</updated>
    <id>http://blog.fasionchan.com/blog/2016/09/20/linux-wen-jian-miao-shu-fu</id>
    <content type="html"><![CDATA[<p>在<a href="http://www.jianshu.com/p/5357d72ef17d">Linux通用I/O模型</a>中，<code>I/O</code>操作系列函数(系统调用)都是围绕一个叫做文件描述符的整数展开。这不禁让人产生疑问：这个整数代表什么？一个数值代表一个文件吗？随便传一个整数进去调用可以吗？</p>

<p>解答以上疑问，需要更深入学习——文件描述符(File Descriptor)。</p>

<!--more-->


<h1>图解</h1>

<p>理解具体情况，需要了解由内核维护的3个数据结构：</p>

<ul>
<li>进程级<strong>文件描述符表</strong>(file descriptor table)</li>
<li>系统级<strong>打开文件表</strong>(open file table)</li>
<li>文件系统<strong>i-node表</strong>(i-node table)</li>
</ul>


<p>这3个数据结构之间的关系如下图所示：</p>

<p><img src="http://blog.fasionchan.com/images/fd-inode-diagram.png"></p>

<h2>文件描述符表</h2>

<p>内核为每个进程维护一个<strong>文件描述符表</strong>，该表每一条目都记录了单个文件描述符的相关信息，包括：</p>

<ul>
<li><strong>控制标志</strong>(flags)，目前内核仅定义了一个，即<code>close-on-exec</code></li>
<li><strong>打开文件描述体指针</strong></li>
</ul>


<h2>打开文件表</h2>

<p>内核对所有打开的文件维护一个系统级别的<strong>打开文件描述表</strong>(open file description table)，简称<strong>打开文件表</strong>。表中条目称为<strong>打开文件描述体</strong>(open file description)，存储了与一个打开文件相关的全部信息，包括：</p>

<ul>
<li><strong>文件偏移量</strong>(file offset)，调用<code>read()</code>和<code>write()</code>更新，调用<code>lseek()</code>直接修改</li>
<li><strong>访问模式</strong>，由<code>open()</code>调用设置，例如：只读、只写或读写等</li>
<li><strong><code>i-node</code>对象指针</strong></li>
</ul>


<h2>i-node表</h2>

<p>每个文件系统会为存储于其上的所有文件(包括目录)维护一个<code>i-node</code>表，单个<code>i-node</code>包含以下信息：</p>

<ul>
<li><strong>文件类型</strong>(file type)，可以是常规文件、目录、套接字或<code>FIFO</code></li>
<li><strong>访问权限</strong></li>
<li><strong>文件锁列表</strong>(file locks)</li>
<li><strong>文件大小</strong></li>
<li>等等</li>
</ul>


<p><code>i-node</code>存储在磁盘设备上，内核在内存中维护了一个副本，这里的<strong><code>i-node</code>表</strong>为后者。副本除了原有信息，还包括：引用计数(从打开文件描述体)、所在设备号以及一些临时属性，例如文件锁。</p>

<h1>场景解析</h1>

<p>上图中，详细描述了两个进程诸多文件描述符，以及相互关系。</p>

<h2>文件描述符复制</h2>

<p>在进程<code>A</code>中，文件描述符1和文件描述符20都指向同一个打开文件描述体(标号23)。这很可能是通过调用<code>dup()</code>系列函数形成的。</p>

<p>文件描述符复制，在某些场景下非常有用，比如：标准输入/输出重定向。在<code>shell</code>下，完成这个操作非常简单，大部分人都会，但是极少人思考过背后的原理。</p>

<p>大概描述一下需要的几个步骤，以标准输出(文件描述符为1)重定向为例：</p>

<ol>
<li>打开目标文件，返回文件描述符n；</li>
<li>关闭文件描述符1；</li>
<li>调用<code>dup</code>将文件描述符n复制到1；</li>
<li>关闭文件描述符n；</li>
</ol>


<h2>子进程继承文件描述符</h2>

<p>进程<code>A</code>的文件描述符2和进程<code>B</code>的文件描述符2都指向同一个打开文件描述体(标号23)。这种情形很可能发生在调用<code>fork()</code>派生子进程之后，比如<code>A</code>调用<code>fork()</code>派生出<code>B</code>。这时，<code>B</code>作为子进程，从父进程<code>A</code>继承了文件描述符表，其中包括图中标明的文件描述符2。这就是<code>子进程继承父进程打开的文件</code>这句话的由来。</p>

<p>当然了，进程<code>A</code>通过<code>Unix</code>套接字将一个文件描述符传递给<code>B</code>也会出现类似的情形，但一般文件描述符数值是不一样的。同时为2要非常凑巧才发生。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux通用IO模型]]></title>
    <link href="http://blog.fasionchan.com/blog/2016/09/17/linux-tong-yong-io-mo-xing/"/>
    <updated>2016-09-17T21:54:29+08:00</updated>
    <id>http://blog.fasionchan.com/blog/2016/09/17/linux-tong-yong-io-mo-xing</id>
    <content type="html"><![CDATA[<p>学习<code>Linux</code>系统编程，文件I/O是一个不错的切入点。首先，日常操作中或多或少都使用过文件，有一定的概念；其次，文件I/O可以由几个最最基础的系统调用完成，降低入门理解难度。</p>

<h1>基础系统调用</h1>

<p><code>Linux</code>下<code>I/O</code>操作是通用化的，不仅仅可以用来操作文件输入输出，还可以用来操作管道、<code>FIFO</code>、<code>socket</code>、终端设备等。将设备抽象成一个文件，用<code>I/O</code>操作控制设备是类<code>Unix</code>系统一大特色。</p>

<!--more-->


<p>最最基础的<code>I/O</code>操作系统调用包括：</p>

<ul>
<li><strong>fd = open(pathname, flags, mode)</strong></li>
<li><strong>rlen = read(fd, buf, count)</strong></li>
<li><strong>wlen = write(fd, buf, count)</strong></li>
<li><strong>status = close(fd)</strong></li>
</ul>


<p>注意到，相关系统调用都围绕文件描述符<code>fd</code>展开。文件描述符在下节详细介绍。</p>

<p>另外，需要特别提示一下，系统调用函数接口（其实是库函数封装）可以通过<code>man</code>命令查看详细的参数、返回值及用法说明。比如，终端下运行<code>man read</code>，就可以看到<code>read</code>这个系统调用的相关文档说明：</p>

<p><img src="http://upload-images.jianshu.io/upload_images/2740477-bb2610e81244463b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="man open" /></p>

<h1>文件描述符</h1>

<p><code>I/O</code>操作系统调用都以文件描述符(一个非负整数)，指代打开的文件。每个进程都有一个打开文件表，可以理解成一个数组，文件描述符可以理解成数组的下标。相关<code>I/O</code>操作系统调用以文件描述符为参数，便可以通过数组访问定位到指定的文件对象，进而进行<code>I/O</code>操作。</p>

<p>一般情况下，进程的标准输入输出由3个特定的文件描述符指定，列举如下：</p>

<table>
<thead>
<tr>
<th style="text-align:left;">文件描述符</th>
<th style="text-align:left;">用途</th>
<th style="text-align:left;">POSIX名称</th>
<th style="text-align:left;">stdio流</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">0</td>
<td style="text-align:left;">标准输入</td>
<td style="text-align:left;">STDIN_FILENO</td>
<td style="text-align:left;">stdin</td>
</tr>
<tr>
<td style="text-align:left;">1</td>
<td style="text-align:left;">标准输出</td>
<td style="text-align:left;">STDOUT_FILENO</td>
<td style="text-align:left;">stdout</td>
</tr>
<tr>
<td style="text-align:left;">2</td>
<td style="text-align:left;">标准错误</td>
<td style="text-align:left;">STDERR_FILENO</td>
<td style="text-align:left;">stderr</td>
</tr>
</tbody>
</table>


<p>正常情况下，程序在开始运行之前，由<code>shell</code>准备好这3个文件描述符。更准确的说法是，程序继承了<code>shell</code>文件描述符的副本，一般是指向<code>shell</code>所在的终端。当然了，可以通过在<code>shell</code>中对输入/输出进行重定向或者在程序启动后关闭并重新打开文件描述符，修改文件描述符指向。</p>

<h1>实战案例</h1>

<h2>读文件</h2>

<p>首先，通过一个例子，探索一下如何通过<code>I/O</code>操作系统调用读取文件内容并输出：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>#include &lt;fcntl.h&gt;
</span><span class='line'>
</span><span class='line'>int
</span><span class='line'>main(int argc, char *argv[])
</span><span class='line'>{
</span><span class='line'>    // 打开文件
</span><span class='line'>    int fd = open("a.txt", O_RDONLY);
</span><span class='line'>    if (-1 == fd)
</span><span class='line'>    {
</span><span class='line'>        perror("fail to open a.txt");
</span><span class='line'>        return -1;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    // 准备缓冲区并读文件
</span><span class='line'>    char buf[1024];
</span><span class='line'>    int rlen = read(fd, buf, sizeof(buf)-1);
</span><span class='line'>    if (-1 == rlen)
</span><span class='line'>    {
</span><span class='line'>        perror("fail to read a.txt");
</span><span class='line'>        return -2;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    // 输出内容
</span><span class='line'>    buf[rlen] = '\0';
</span><span class='line'>    printf("read %d bytes, which is:\n", rlen);
</span><span class='line'>    printf("%s\n", buf);
</span><span class='line'>
</span><span class='line'>    // 关闭文件
</span><span class='line'>    int status = close(fd);
</span><span class='line'>    if (-1 == status)
</span><span class='line'>    {
</span><span class='line'>        perror("fail to close a.txt");
</span><span class='line'>        return -3;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>写文件</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>#include &lt;string.h&gt;
</span><span class='line'>#include &lt;fcntl.h&gt;
</span><span class='line'>
</span><span class='line'>int
</span><span class='line'>main(int argc, char *argv[])
</span><span class='line'>{
</span><span class='line'>    // 打开文件
</span><span class='line'>    int fd = open("a.txt", O_WRONLY);
</span><span class='line'>    if (-1 == fd)
</span><span class='line'>    {
</span><span class='line'>        perror("fail to open a.txt");
</span><span class='line'>        return -1;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    // 准备数据并写到文件
</span><span class='line'>    char data[] = "hello, this is line written by write syscall\n";
</span><span class='line'>    int wlen = write(fd, data, strlen(data));
</span><span class='line'>    if (-1 == wlen)
</span><span class='line'>    {
</span><span class='line'>        perror("fail to read a.txt");
</span><span class='line'>        return -2;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    // 输出成功写入字节数
</span><span class='line'>    printf("write %d bytes of %d total\n", wlen, strlen(data));
</span><span class='line'>
</span><span class='line'>    // 关闭文件
</span><span class='line'>    int status = close(fd);
</span><span class='line'>    if (-1 == status)
</span><span class='line'>    {
</span><span class='line'>        perror("fail to close a.txt");
</span><span class='line'>        return -3;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[围观Scrapy爬虫框架]]></title>
    <link href="http://blog.fasionchan.com/blog/2015/04/11/wei-guan-scrapy-pa-chong-kuang-jia/"/>
    <updated>2015-04-11T11:22:24+08:00</updated>
    <id>http://blog.fasionchan.com/blog/2015/04/11/wei-guan-scrapy-pa-chong-kuang-jia</id>
    <content type="html"><![CDATA[<p>对于Scrapy这个爬虫框架，先前也是知道有这么个东西存在，仅此而已。最近在面试时，发现很多人写过Python爬虫采集数据，所用的框架几乎都是Scrapy。今天刚好闲着没事做，就来玩玩Scrapy呗。</p>

<h2>简介</h2>

<h2>框架</h2>

<p><img src="http://blog.fasionchan.com/images/scrapy.png"></p>

<!--more-->


<h2>安装</h2>

<p>需要先安装几个依赖库：<code>apt-get install libxml2-dev libxslt1-dev python-dev libffi-dev</code>。采用PIP方式安装Scrapy，被依赖的Twisted也将自动安装：<code>pip install scrapy</code>。安装时，可能会报libxml头文件找不到：<code>fatal error: libxml/xmlversion.h: No such file or directory</code>。在我的机器上，运行<code>dpkg -L libxml2-dev</code>看看先前安装的依赖包<code>libxml2-dev</code>所有文件安装点，发现其头文件位于<code>/usr/include/libxml2/libxml</code>，将其软链到<code>/usr/include/</code>便解决问题。</p>

<h2>组件</h2>

<h2>示例</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HTTP压力测试潜在问题若干]]></title>
    <link href="http://blog.fasionchan.com/blog/2015/03/27/http-ya-li-ce-shi-qian-zai-wen-ti-ruo-gan/"/>
    <updated>2015-03-27T16:56:02+08:00</updated>
    <id>http://blog.fasionchan.com/blog/2015/03/27/http-ya-li-ce-shi-qian-zai-wen-ti-ruo-gan</id>
    <content type="html"><![CDATA[<p>首先，用<code>ulimit -n</code>看看是不是文件描述符设置过小而被打满：发现设置值是<code>65536</code>，这是<code>10000</code>个并发不可能用满的。当然，大部分服务器上都是采用默认配置<code>1024</code>，这时就是罪魁祸首了。</p>

<h2>backlog太小</h2>

<p>各种可能的原因都查了查了，最后发现是由于底层套接字调用<code>listen</code>时<code>backlog</code>参数太小造成的！<code>listen</code>系统调用的作用是使TCP套接字进行监听状态，<code>backlog</code>是内核维持请求连接队列的个数限制（不包括已经被accept的连接）。我要测试的WEB接口是用基于<code>tornado</code>框架的，绑定端口时<code>backlog</code>默认参数是<code>128</code>，很快就被<code>10000</code>个请求给压满了，这就是<code>ab</code>各种超时的主要原因！调大这个参数后问题就解决了~</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[随机文段生成]]></title>
    <link href="http://blog.fasionchan.com/blog/2015/03/25/sui-ji-wen-duan-sheng-cheng/"/>
    <updated>2015-03-25T20:40:54+08:00</updated>
    <id>http://blog.fasionchan.com/blog/2015/03/25/sui-ji-wen-duan-sheng-cheng</id>
    <content type="html"><![CDATA[<p>我们经常需要拷贝一些文字作为Demo填充，特别是做页面时，每次都到网上去找觉得挺麻烦的。很多时候我们也需要一个随机的信息流，比如模拟后台日志输出。Python下<a href="https://pypi.python.org/pypi/loremipsum/">loremipsum</a>就可以很好地完成这个工作，安装很简单：<code>pip install loremipsum</code>。使用示例如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt;&gt;&gt; import loremipsum
</span><span class='line'>&gt;&gt;&gt; dir(loremipsum)
</span><span class='line'>['DictionaryError', 'Generator', 'SampleError', '_GENERATOR', '__all__', '__author__', '__builtins__', '__classifiers__', '__copyright__', '__doc__', '__docformat__', '__file__', '__keywords__', '__name__', '__package__', '__path__', '__version__', 'generate_paragraph', 'generate_paragraphs', 'generate_sentence', 'generate_sentences', 'generator', 'get_paragraph', 'get_paragraphs', 'get_sentence', 'get_sentences']
</span><span class='line'>&gt;&gt;&gt;
</span><span class='line'>&gt;&gt;&gt; # 生成一个随机句子
</span><span class='line'>&gt;&gt;&gt; print loremipsum.get_sentence()
</span><span class='line'>Purus neque fames vivamus.
</span><span class='line'>&gt;&gt;&gt;
</span><span class='line'>&gt;&gt;&gt; # 生成一个随机段落
</span><span class='line'>&gt;&gt;&gt; print loremipsum.get_paragraph(10)
</span><span class='line'>Lorem ipsum. Vitae massa aenean mi pulvinar montes tortor felis feugiat. Morbi risus. Etiam class tortor parturient volutpat dolor a integer mollis. Neque felis. Fusce ipsum massa dui purus penatibus phasellus fusce phasellus cursus. Felis augue nunc egestas natoque dictum dolor mus. Massa metus donec eni nibh habitasse ut tortor mi orci aliquet risus in. Lorem augue per tellus convallis facilisi eu purus suspendisse. Velit purus sem felis tincidunt cras. Fusce neque luctus magnis fusce. Class dolor egestas hac eleifend tincidunt. Lacus neque ligula sollicitudin facilisis tortor inceptos non id nunc.</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SSH高级用法]]></title>
    <link href="http://blog.fasionchan.com/blog/2015/03/22/ssh-gao-ji-yong-fa/"/>
    <updated>2015-03-22T10:21:52+08:00</updated>
    <id>http://blog.fasionchan.com/blog/2015/03/22/ssh-gao-ji-yong-fa</id>
    <content type="html"><![CDATA[<h2>Keep Alive</h2>

<p>在某些网络环境下，SSH会话空闲一小段时间后就会断掉。可能是因为中间有个NAT网关，检查到空闲TCP连接后便无情Kill。一暂停操作SSH连接就断实在不能忍！</p>

<p>SSH有个配置选项，每隔一段时间就发一个空包使TCP连接保持活跃，这样连接就不会无故断掉了。这个选项就是：<code>ServerAliveInterval</code>，配置值是一个整数，表示发送空包的周期，单位是秒。</p>

<!--more-->


<p>这个选项可以作为全局配置写在<code>/etc/ssh/ssh_config</code>，影响每个用户的每一个SSH连接：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>ServerAliveInterval 60
</span></code></pre></td></tr></table></div></figure>


<p>也可以作为用户配置写在当前用户的配置文件<code>~/.ssh/config</code>里（如果这个配置文件不存在，可以手动创建）：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>Host *
</span><span class='line'>    ServerAliveInterval 60
</span></code></pre></td></tr></table></div></figure>


<p><code>Host</code>可以指定对哪些服务器应用该配置，<code>*</code>通配符可以匹配所有服务器，<code>*.hostname.com</code>则可以匹配所有名字以<code>.hostname.com</code>结尾的服务器。</p>

<h2>代理传递</h2>

<p>假设用ssh登陆管理两台机器A和B：把公钥部署上去，然后本地就可以不通过密码验证登陆上去。如果要把A机器上一个文件传到B机器上，那么，比较显然易见的方式是：先用scp把文件从A拉到本地，然后再从本地传到B。这显然比较繁琐，如果A能够ssh到B，那就方便很多。但不论是把本地私钥部署到A机器还是在A机器生产私钥都是不妥的，万一A被攻破，那么B也就会遭殃。</p>

<p>这时候ssh代理传递（ssh agent forwarding）就派上用场了。通过代理传递，从本地ssh到机器A，那么在A就可以ssh到任何本地可以ssh的机器。假设这时ssh到B，A借助本地的私钥信息完成验证，而A上无须部署任何私钥。这个过程就像把本地的ssh私钥传递到机器A。</p>

<h3>设置方法</h3>

<p>只需要本地ssh配置文件~/.ssh/config加上如下配置：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>Host server1.example.com
</span><span class='line'>    ForwardAgent yes
</span></code></pre></td></tr></table></div></figure>


<p>这个配置的含义是，本地ssh可以传递到<code>server1.example.com</code>上，也就是ssh到<code>server1.example.com</code>后，你可以在服务器上ssh到其他机器。这里需要注意的是：<code>server1.example.com</code>必须是跟你的ssh命令保持一致<code>ssh server1.example.com</code>！如果ssh使用的是IP，那么配置里面也必须填IP；如果把<code>example.com</code>设置成域，ssh使用机器名<code>server1</code>，那么配置文件也必须使用机器名，尽管指的都是同一台机器。</p>

<h2>反向代理</h2>

<p>经常需要从家里连到公司内网的电脑，在没有VPN的情况下该怎么办呢？NAT技术解决了内网机器通过网关访问外网，但是在网关没有映射相关端口的情况下，从外网访问内网服务将是不可能的。</p>

<p>本质上，SSH反向代理就是把一台机器的某个服务端口映射到另一台机器上。如果采用SSH反向代理，把内网机器<code>A</code>的SSH端口映射到外网机器<code>B</code>的某个端口，不就解决问题了么？那么，怎么配置SSH反向代理呢？</p>

<p>在<code>A</code>机器上执行<code>ssh -fNR addrB:portB:addrA:portA user@addrB</code>，将在<code>B</code>机器地址<code>addrB</code>上开启<code>portB</code>端口，并将请求映射到本地（<code>A</code>机器）地址<code>addrA</code>上的<code>portA</code>端口。另外，<code>user</code>为<code>B</code>机器上的用户，<code>user@addrB</code>用来登录<code>B</code>机器。完成SSH反向代理后，访问<code>addrB</code>的<code>portB</code>端口即是访问<code>addrA</code>的<code>portA</code>端口。具体用法请参考<code>man ssh</code>文档。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Kafka简介]]></title>
    <link href="http://blog.fasionchan.com/blog/2015/03/21/kafka-jian-jie/"/>
    <updated>2015-03-21T11:01:38+08:00</updated>
    <id>http://blog.fasionchan.com/blog/2015/03/21/kafka-jian-jie</id>
    <content type="html"><![CDATA[<p><a href="http://kafka.apache.org">Kafka</a>是一个高吞吐的分布式消息系统，由<a href="http://www.linkedin.com">Linkin</a>公司开源，成为一个<a href="https://www.apache.org">Apache</a>项目。Kafka可以看做是一个快速、分布式、可扩展、可分区、可复制、持久化的日志服务。它提供了作为消息系统的实用功能，架构设计却是相当独特的。</p>

<h2>发布-订阅模型</h2>

<p><img src="http://blog.fasionchan.com/images/kafka-producer-consumer.png"></p>

<ul>
<li>Kafka采用话题（topic）对消息进行分类；</li>
<li>向Kafka发布（Publish）消息的进程称为生产者（producer）；</li>
<li>从Kafka订阅（Subscribe）消息的进程称为消费者（consumer）；</li>
<li>Kafka集群可以由若干台服务器组成，称为代理（broker）；</li>
</ul>


<!--more-->


<h2>话题和日志</h2>

<p>话题是消息的分类名：生产者向某个话题发布消息；消费者从某个话题订阅消息。一个话题可以分为多个分区（partition），分区的作用：首先，当消息规模扩张到超过一台机器的处理能力时，可以把压力分散到多台机器；其次，分区也让应用并行处理消息成为可能。Kafka组织分区日志的方式如下：</p>

<p><img src="http://blog.fasionchan.com/images/kafka-log-anatomy.png"></p>

<p>发布到一个话题的消息写到该话题下某一分区，由消息所带的键（key）决定：<strong>键相同的所有消息落到同一个分区</strong>。每个分区都是一个有序不可变的消息序列，持续地追加到一个提交日志（commit log）。Kafka为分区中的每条消息分配了一个序号，称为偏移量（offset），唯一指定了每条消息在分区中的位置。</p>

<p>Kafka根据配置周期保留周期内的所有消息，不管消息有没有被消费。例如，如果日志被配置成保留两天，那么一个消息发布后的两天内都是可供消费的，两天之后才会被清除以释放空间。</p>

<p>Kafka维护的元数据只有消费者在日志中的位置，也就是偏移量（offset）。事实上，这个偏移量是由消费者控制的：正常情况下消费者在读消息的时候线性自增其偏移量。这样看来，消费者可以以任意顺序消费消息；也可以通过重置偏移量从新处理消息，这一点非常有用。</p>

<p>这些特性决定了Kafka消费者将是非常灵活的：可以随时进入、随时离开而不会对集群或其他消费者产生影响。例如，可以使用Kafka提供的命令行工具来&#8221;tail&#8221;任何话题的内容而不用担心会影响到已经存在的消费者。</p>

<h2>用法示例</h2>

<p><img src="http://blog.fasionchan.com/images/kafka-usecase.png"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[写于除夕夜]]></title>
    <link href="http://blog.fasionchan.com/blog/2015/02/18/xie-yu-chu-xi-ye/"/>
    <updated>2015-02-18T20:03:26+08:00</updated>
    <id>http://blog.fasionchan.com/blog/2015/02/18/xie-yu-chu-xi-ye</id>
    <content type="html"><![CDATA[<h2>工作</h2>

<p>这部分不准备多写：在公司外透漏工作细节是不合适的。毕业后选择了运维方向，与开发不同，对运维来说，最重要的词是稳定、可靠和可控。这个职位总体工作强度不高，但是突发情况较多。我本身不是纯运维，而是运维开发，就是开发运维系统。尽管如此，平时多少还是要做一些运维操作，提心吊胆地享受命令行带给你的快感。借用领导的话：你做的好，没人会想起你；你搞出一次事故，大家就都知道这个运维不靠谱！</p>

<!--more-->


<p>百密必有一疏，不久前就因为偷懒搞出一次事故：那天跟同事接线上的消息队列测试服务，一直到晚上9点准备下班。测试队列必须删掉，避免数据积攒撑坏系统。好几十个队列不可能通过WEB页面一个个点点点删掉吧？就考虑用Python调用消息队列的WEB API去删。偷懒只调出Python控制台，拼URL，请求，遍历每个队列，匹配测试队列，打印确认。一步步都在预料之中，接下来可以发出删除请求了。一条条回翻前面的语句，可偏偏少翻了匹配测试队列那条if语句，结果是对每个队列都发起删除请求。看着线上队列一个个出现在我的终端时，马上退出，但是几百个队列已经有近一半被删掉了。这意味着相关系统已经开始丢数据了，整个人在那瞬间傻愣了一下，太紧张头脑短路了。稍微定了一下后开始处理受影响的各个系统，接消息队列的每个系统都受到影响！这个事故造成了大约一个小时的数据丢失，第一次敲键盘有一种手心冒汗的感觉。脚本化可以杜绝少敲点什么的风险，但就是偷懒选择了控制台，因为控制台更灵活，更方便调试。做什么重要操作都应该采用最安全的方式，而不是最方便的方式。</p>

<p>Any way，经过一年勤勤恳恳工作，拿到一次职级提升的机会，现在的title已经是“资深系统运维工程师”了。但，我更希望是工资大大滴涨~</p>

<h2>投资</h2>

<p>觉得投资是现代人必须掌握的一项技能：财富的保值增值至少与积累一样重要。任何政府都有超发货币的欲望（变相税收且无成本），由此带来的通货膨胀稀释百姓手中的财富。试想十年前100元的购买力跟今天差别多大！</p>

<p>说来惭愧，毕业至今，积蓄寥寥。第一年里换了电脑、手机，买Kindle、自行车等，就一个感觉——紧。再往前，2013年烧钱的毕业季，还好春节过后不久就硬着头皮先去公司实习，不然真心hold不住的（代价则是错过好多风景）。然后就是助学贷款以及押二付一的房租，借了一堆债。至于搞定这一切，已是2014年初了。</p>

<p>起初图个方便，买了只货基了事，总比放银行好。后来买了一点P2P债权，15%的收益，也是比较省心。不少人看好美元资产，我也有意要做美股。念头年初就有，待到7月完成史考特账号申请，以及11月份拿到香港银行卡，已经小一年过去了。执行力在哪里！！！</p>

<p>11月底，东拼西凑投了5万块（qiong）进去，还分了两处：2万多港币的港股以及4千多美金的美股。本儿小来去自如，但是佣金却吃掉利润的一大块。12月至1月初收益不错，账面有2千多的利润。但是1月中下旬几次亏损带走了前面的几乎所有利润，记得有一天晚上，忍痛止损，那笔交易亏了200多美金。期间，也经历过一个晚上赚一千多块的兴奋。慢慢地，平静下来，淡定许多。对比起初，一看实时行情就智商降低，失去理性；现在好很多了，不会急于买入，也不会急于卖出。2月收益也不多，基本填上1月几次亏损而已。算下来，入场近3个月，5万本金收了2千租金，年化收益率也就16%，这还是算上美元升值的，学习空间还很大。</p>

<h3>国内经济基本面</h3>

<p>本人对国内经济没有太大的信心：增速降了，房地产做不下去了，新增长点没看到，美联储也要放大招了（加息）。2014年后半年，在路上，在公园门口，在小区门口，举着牌子卖房的中介貌似多了不少。这说明，房地产已经慢慢变为买方市场。也可以认为：人们对房价是否能涨信心不足。至于信心降了多少，会有多少影响，小菜不才，不知道。但至少说明，前面有相当的风险。</p>

<p>这就是去年A股大牛而我不敢进的原因——大涨背后没有一个良好的基本面做支撑，而接下来的光景，可能会更加艰难。上个月证监会对多家券商开出两融业务罚单，整顿两融业务，也印证了坊间关于杠杆牛市的传闻。不知道水多深，觉得还是继续观望算了：“眼看他起朱楼，眼看他宴宾客”。</p>

<p>国内唯一的利好应该就是十八届三中全会释放出的改革信号，同时也已经在多个领域全面推动。习大大上台后，放了几个大招，打掉好几个大老虎。封建时代上来一个明君也可以打老虎，天下太平几年，后事未可知。靠英明领袖的反腐总是有局限的，利益集团阻碍改革的力量也是强劲的。衷心希望习大大和李大大能够顺利推动这次久违的改革，让反腐制度化，让改革的红利落地。</p>

<h2>旅行</h2>

<p>一直没怎么出去走：整年7天年假，怎么够用！而请假去旅游的成本很高，现在又是艰苦奋斗攻坚克难的阶段（调侃下官腔），就没这么出去玩儿。回家后，为释放空间把手机数据导入硬盘，照片记录了我这一年的足迹。如图已说明一切：这一年很宅！基本上就是广州和揭阳，两点成一线。另外俩孤点是：10月份去北京出差；12月份去台湾旅游。</p>

<p><img src="http://blog.fasionchan.com/images/2014-nian-wo-de-zu-ji-iphoto.png"></p>

<h3>北京</h3>

<p>国庆后，跟老大们到北京出差——校园招聘面试。我的任务比较轻松，前两天一面过后就没我什么事了。在老大们在忙二面，挑人，发Offer时，我跑出去玩了一天！一天的时间并不多，逛了不少地方，基本上都是走马观花了：北海公园、景山公园、故宫以及南锣鼓巷胡同。这个次游览也算是计划外的事了，没什么准备，也发现北京好玩的地方太多了。不到长城非好汉，是的，没时间去！那天本来还想去恭王府的（近代的恭亲王奕欣大名赫赫），但是故宫太大，一进去一时半会出不来，就也没去成。</p>

<p>哦，对了，说好的雾霾呢？出发前在墨迹上看还有，到机场那天晚上就逐渐消退了，我都无福消受，哈哈哈~</p>

<p><img src="http://blog.fasionchan.com/images/bei-hai-gong-yuan-bai-ta.jpg"></p>

<p><img src="http://blog.fasionchan.com/images/bei-hai-gong-yuan-liu-ying.jpg"></p>

<h3>台湾</h3>

<p>台湾行是公司组织的年度旅游，但其实应该感谢党，没有党给发的通行证，我是去不了的。说起通行证，真是一波三折：中秋回家顺手把通行证和护照给办了，以为妥妥了。后来得知个人签注去台湾要准备好多资料，好吧，认了：在职证明，各种户口本复印件和联络人身份证复印件。接着又得知，大揭阳发的个人签注只能去澎湖、花莲的若干山区……同事都说不如跟他们一起去日本了，但我觉得，只要党还给机会，我就要去台湾。打电话问了一下广州天河公安局，能不能在广州异地改签注。答案是可以，但首先要一年社保以及暂住证。社保Ok，联系房东要房产证复印件办暂住证，然后才搞定改签。感谢党，最后还是及时给我发了签注。</p>

<p>台湾经济没有想象中发达，但是到处都很整洁，还是挺赞的~在那5天里一天至少走一个城市，一下子刷新我在广东留下的足迹记录。玩过的地方包括：国父纪念馆、101大楼、台北故宫、野柳风景区、台中禅寺、日月潭、阿里山、垦丁、高雄港和高雄梦时代。行程也是走马观花式，每天坐旅游大巴去一个景点，下车参观一会儿，走走看看，拍拍照就离开了。</p>

<p>还好安排了两次夜市自由吃喝闲逛，才有机会深入体验台湾人民的生活（深入群众我党注）。台湾人民还是比较用心呀，好多好吃的都很好吃，也比较实惠。景区边的饭店也不会像国内那样就只想宰客，味道赞，服务到位。吃货到台湾就是吃吃吃：从北到南，我们几乎每天都吃猪脚，但是每一顿的风味都不一样；人均只要100的鱼虾蟹大餐；还有夜市里各种令人欲罢不能的海鲜！有机会还真想再去一次！</p>

<p><img src="http://blog.fasionchan.com/images/101-da-lou.jpg"></p>

<p><img src="http://blog.fasionchan.com/images/tai-bei-gu-gong.jpg"></p>

<p><img src="http://blog.fasionchan.com/images/tai-zhong-chan-si.jpg"></p>

<p><img src="http://blog.fasionchan.com/images/ri-yue-tan.jpg"></p>

<p><img src="http://blog.fasionchan.com/images/gao-xiong-gang.jpg"></p>

<h2>计划</h2>

<ul>
<li>读万卷书，现在时间实在太少，先完成正在读的这几本：《宇宙的琴弦》、《极简欧洲史》、《乱世中的大国崛起》、《利率史》、《民国课堂——大先生也挺逗》</li>
<li>行万里路，从脚下开始，肇庆惠州，香港澳门这么近的地方还没去溜达过呢</li>
<li>怀着对市场的敬畏学习投资和交易</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用黑客的方式写博客]]></title>
    <link href="http://blog.fasionchan.com/blog/2015/01/18/yong-hei-ke-de-fang-shi-xie-bo-ke/"/>
    <updated>2015-01-18T15:34:34+08:00</updated>
    <id>http://blog.fasionchan.com/blog/2015/01/18/yong-hei-ke-de-fang-shi-xie-bo-ke</id>
    <content type="html"><![CDATA[<p><img src="http://blog.fasionchan.com/images/gitpress.png"></p>

<!--more-->


<h2>开始写博客</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c"># 新建post，标题为title</span>
</span><span class='line'>rake new_post<span class="o">[</span><span class="s2">&quot;title&quot;</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<h2>常用语法</h2>

<h3>关键字</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>---
</span><span class='line'>layout: post
</span><span class='line'>title: <span class="s2">&quot;Linux文件描述符&quot;</span>
</span><span class='line'>date: 2016-09-20 22:16:26 +0800
</span><span class='line'>comments: <span class="nb">true</span>
</span><span class='line'>categories: Linux
</span><span class='line'>keywords: linux, file descriptor, 文件描述符
</span><span class='line'>---
</span></code></pre></td></tr></table></div></figure>


<h3>图片</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="o">{</span>% img /images/bei-hai-gong-yuan-bai-ta.jpg %<span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>常见问题</h2>

<p>自定义域名配置<code>CNAME</code>不生效，查了很久发现是<code>Jekyll</code>失效引起的。</p>
]]></content>
  </entry>
  
</feed>
